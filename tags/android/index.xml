<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on My New Hugo Site</title>
    <link>http://example.org/tags/android/</link>
    <description>Recent content in Android on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Jan 2017 13:12:00 +0800</lastBuildDate><atom:link href="http://example.org/tags/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Scala 语言开发Andorid ，开发环境的搭建(二)</title>
      <link>http://example.org/posts/scala_android_sby2/</link>
      <pubDate>Tue, 17 Jan 2017 13:12:00 +0800</pubDate>
      
      <guid>http://example.org/posts/scala_android_sby2/</guid>
      <description>什么是 sbt ？ 上一篇文章介绍过，sbt 就是和 maven ，ant 类似的自动构建工具。 那 sbt 有什么优势呢？
 相对其他构建工具更快的编译速度，只编译修改过的文件以及引用的第三方库依赖 triggered execution 特性方便做测试驱动的开发 依据类和依赖使用 Scala 的解析器 sbt 是基于 Scala ，所以可以灵活的使用 Scala 构建工程 支持 java 和 Scala 的混合编程  基本目录 工程的根目录下的文件和文件夹，下面看看文件夹里面到底是什么东西。
源码 根下的 src 目录就是存放源码文件的地方呢
src/ main/ resources/ &amp;lt;files to include in main jar here&amp;gt; scala/ &amp;lt;main Scala sources&amp;gt; java/ &amp;lt;main Java sources&amp;gt; test/ resources &amp;lt;files to include in test jar here&amp;gt; scala/ &amp;lt;test Scala sources&amp;gt; java/ &amp;lt;test Java sources&amp;gt; sbt 配置文件 在一个小项目中一两个 sbt 文件已经足够了，当时随着项目的扩展有可能要同时管理多个 sbt 文件</description>
    </item>
    
    <item>
      <title>Scala 语言开发Andorid ，开发环境的搭建(一)</title>
      <link>http://example.org/posts/scala_android_sby/</link>
      <pubDate>Tue, 10 Jan 2017 21:43:00 +0800</pubDate>
      
      <guid>http://example.org/posts/scala_android_sby/</guid>
      <description>厌倦 Java 繁琐的语法，为了更优雅的开发 Android 程序，Scala 代替 Java 是一个不错的尝试。 开发前可以学习 Scala 的基本语法，某些部分和 Java 非常类似，但又聚合了其他先进语言的特性。与 Java 不同的是，在你熟悉函数式编程的情况下能写出更加优雅的代码。
SBT 构建工具 现在绝大多数的 Android 开发者是官方提供的 Android Studio ，这个 IDE 使用的是基于 Gradle 的自动化建构工具，通过 Gradle 可以配置 Project 各种参数，生产 APK 等操作。 SBT 是和 Gradle,Ant,Maven 一样的自动化建构工具，SBT 方便管理我们用 Scala 编写的 Android 工程。
和使用 Java 开发 Andoird 一样，首先要安装 Scala， 下载 官方文件，在此之前先确定电脑已经安装配置好 Java 环境。如果 macOS 已经安装有 Homebrew 只需要一行代码即可安装配置成功
brew install scala 接着安装 SBT 同一也一行代码搞定(赶紧换一台 mac 吧~~
brew install sbt 其他系统的配置大可直接看 [Scala]((http://scala-lang.org/) 和 SBT 官网，里边有详细的安装配置教程</description>
    </item>
    
    <item>
      <title>ImageView的使用笔记</title>
      <link>http://example.org/posts/imageviwe_note/</link>
      <pubDate>Mon, 28 Nov 2016 11:20:00 +0800</pubDate>
      
      <guid>http://example.org/posts/imageviwe_note/</guid>
      <description>一、使用ImageView 的src 和background  src ：原图大小，不被拉伸;
background：为Imageview的背景，根据ImageView给长宽进行拉伸；
 二、设置Imageview的透明度  android:src在设置ImageView的setAlpha(int alpha)时，起作用;
android:background在设置ImageView的setAlpha(int alpha)时，不起作用;
 mImageView.setBackgroundDrawable(mDrawable.mutate()); mImageView.getBackground().setAlpha(100); 三、设置ImageView的前景（foreground） 有时候设计需要在ImageView 上面覆盖一层（如灰色）
 View 提供了一个setForeground(Drawable foreground)
 四、使用ImageView的“android:adjustViewBounds” 如果想设置图片固定大小，又想保持图片宽高比，需要如下设置：
 设置setAdjustViewBounds为true； 设置maxWidth、MaxHeight； 设置设置layout_width和layout_height为wrap_content  五、正确使用ImageView的“android:scaleType” ImageView的“android:scaleType”属性是对src才有效的
ScaleDrawable类是afc框架中提供了一个专门处理Drawable scale的类，在ImageView的ScaleType的基础上额外提供了11中裁剪方式：
（1）CROP_CENTER （2）CROP_START （3）CROP_END （4）FIT_CENTER （5）FIT_START （6）FIT_END （7）MATCH_WIDTH_TOP （8）MATCH_WIDTH_BOTTOM （9）MATCH_WIDTH_CENTER （10）CENTER （11）CROP_BY_PIVOT  要保证ScaleDrawable.CROP_START属性设置成功，在xml中一定要设置“android:scaleType=”fitXY”
 </description>
    </item>
    
    <item>
      <title>Android 内存泄露的几中场景</title>
      <link>http://example.org/posts/memory_leak/</link>
      <pubDate>Tue, 22 Nov 2016 13:57:00 +0800</pubDate>
      
      <guid>http://example.org/posts/memory_leak/</guid>
      <description>java 存在一个垃圾回收机制，发生泄漏的原因就是应该被回收的垃圾没有被回收，这种情况就叫做内存泄漏
解决内存泄漏的方法的思路：让不易回收的内存可以在不需要继续使用单情况下被系统回收掉。
怎么做在能让某些内存可以被及时回收呢？这里就需要了解 java 的一个知识点，这就是引用类型。java 分 四 种引用类型，分别是：强引用，软引用，弱引用，虚引用。这从这四种引用点名称可以推测，系统对于不用类型引用有不同的回收机制。为方便对比列出下方的表格
   引用类型 回收条件 发生泄漏可能性     强引用 不回收 可能   软引用 内存不足时回收 不可能   弱引用 一定回收 不可能   虚引用 不回收 可能    合理点使用不同的引用类型，可以避免出现内存泄露的情况
在Android开发中，出现内存泄露我认为可以分为两大部分，一部分是 java 相关的，另一部分是 Android Api使用容易出现内存泄露
常见有以下场景
1. 单例模式 单例模式生成的静态对象因为生命周期和应用的进程一致，一般只有当应用退出或者运行的进程被结束，对象才能结束对象的生命周。例如当一个单例对象引用一个 activity 变量，即便 activity 可能已经退出了，但是因为单例对象还持有 activity ，所以系统不能回收这个 activity 造成了内存泄露
 解决方案
使用弱应用，例如
private WeakReferencewr = null;
wr = new WeakReference(myActivity);
 2.</description>
    </item>
    
    <item>
      <title>BindSevice的几种使用方法</title>
      <link>http://example.org/posts/bindsevice/</link>
      <pubDate>Tue, 11 Oct 2016 22:00:07 +0800</pubDate>
      
      <guid>http://example.org/posts/bindsevice/</guid>
      <description>绑定服务 绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。 绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。
Sevice 以下这个服务可让客户端通过 Binder 实现访问服务中的方法
	public class LocalService extends Service { IBinder mBinder = new LocalBinder(); private final Random mGenerator = new Random(); public class LocalBinder extends Binder { LocalService getService() { return LocalService.this; } } @Nullable @Override public IBinder onBind(Intent intent) { return mBinder; } public int getRandomNumber() { return mGenerator.nextInt(100); } } Client 	public class MainActivity extends Activity { LocalService mService; Button button; Boolean mBound; @Override protected void onCreate(Bundle savedInstanceState) { super.</description>
    </item>
    
  </channel>
</rss>
