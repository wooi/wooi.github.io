
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Android on 同文館</title>
   <link>https://wooi.github.io/tags/android/</link>
   <description>Recent content in Android on 同文館</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <lastBuildDate>Tue, 17 Jan 2017 13:12:00 +0800</lastBuildDate>
   
       <atom:link href="https://wooi.github.io/tags/android/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>Kotlin的函数式编程思维</title>
       <link>https://wooi.github.io/posts/funtional_programing/</link>
       <pubDate>Wed, 28 Apr 2021 20:45:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/funtional_programing/</guid>
       <description>&lt;h2 id=&#34;kotlin的函数式编程思维&#34;&gt;Kotlin的函数式编程思维&lt;/h2&gt;&lt;h4 id=&#34;定义&#34;&gt;定义&lt;/h4&gt;&lt;p&gt;学习编程之前，我们对函数的理解更多是数学上的定义例如 f=(x) ,学习了编程之后我们对函数的定义编程了一种方法（Method）,方法更多的是它能做什么，而函数表示的则是输入到输出的映射。所以函数式编程更靠近与数学上函数的概念，输入到输出之间的一个映射关系。显而易见的好处是输入固定，输出也是固定的。往函数里面输入一个值，用于有一个值以此对应。函数式编程的特点&lt;/p&gt;&lt;ul&gt;&lt;li&gt;函数是一种值&lt;/li&gt;&lt;li&gt;不变性&lt;/li&gt;&lt;li&gt;没有副作用&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不变型和没有副作用，对于单一方法的调试，排查更加简单，加入线上出现某个Bug，开发者定位到了相关的函数，根据出现的结果推到出对应的输入值，在某个方法中的问题分析少去了其他无用的上下文理解。&lt;/p&gt;&lt;p&gt;####Lambda表达式的演进&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printUserName&lt;/span&gt;(name:String):Unit{print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User:&amp;#34;&lt;/span&gt;+name)}blockOfCode = &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printUserName&lt;/span&gt;(name:String):Unit{print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User:&amp;#34;&lt;/span&gt;+name)}blockOfCode = printUserName(name:String):Unit{print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User:&amp;#34;&lt;/span&gt;+name)}blockOfCode = printUserName(name:String){print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User:&amp;#34;&lt;/span&gt;+name)}blockOfCode = (name:String){print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User:&amp;#34;&lt;/span&gt;+name)}blockOfCode = (name:String){print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User:&amp;#34;&lt;/span&gt;+name)}blockOfCode = (name){print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User:&amp;#34;&lt;/span&gt;+name)}blockOfCode = (name) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User:&amp;#34;&lt;/span&gt;+name)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;blockOfCode 函数的使用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;val blockOfCode = (name) -&amp;gt; print(&amp;quot;User:&amp;quot;+name)blockOfCode(&amp;quot;Tim&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####非纯函数与纯函数&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//非纯函数&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; preValue : Int = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addNotPure&lt;/span&gt;(currentValue : Int):Int {    preValue = preValue + currentValue    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; preValue}&lt;span style=&#34;color:#75715e&#34;&gt;//纯函数&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addPure&lt;/span&gt;(cur : Int , pre : Int): Int {    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cur + pre}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;高级函数&#34;&gt;高级函数&lt;/h4&gt;&lt;p&gt;高阶函数是将函数用作参数或返回值的函数。&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(x, y, f):    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; f(x) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; f(y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;从java-到kotlin的实例应用&#34;&gt;从Java 到Kotlin的实例应用&lt;/h4&gt;&lt;p&gt;无限长的 if else，通过高级函数的特性可以对这钟场景做代码的拆解和重构&lt;/p&gt;&lt;pre&gt;&lt;code&gt;fun get(type:Int) {if(type  == TYPE_A) {return A()}else if (type  == TYPE_B) {return B()}else if (type  == TYPE_C) {return C()}else if (...) {return D()}else if (...) {return E()}else if (...) {return F()}}//函数式的写法var fa = () -&amp;gt; Afun fb = () -&amp;gt; Bfun fc = () -&amp;gt; Cfmap = mapOf(TYPE_A to fa,TYPE_B to fb,TYPE_C to fc,)fun get(type:Int) {return fmap(type)}&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;库里化&#34;&gt;库里化&lt;/h4&gt;&lt;p&gt;curry：把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数这样，可以简化函数的多个参数.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//普通&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(x: Int, y: Int): Int {    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x + y}&lt;span style=&#34;color:#75715e&#34;&gt;//柯理化&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(x: Int): (Int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Int {    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt;(y: Int): Int {        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x + y    }}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;惰性求值&#34;&gt;惰性求值&lt;/h4&gt;&lt;p&gt;惰性求值时函数式编程语言常见的一种特性，就是不需要立刻运行，等待有需要时再执行“复杂”的运算。&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;makePowerFn&lt;/span&gt;(power: Double): (Double) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Double {    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt;(base: Double): Double {        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pow(base, power)    }}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;记忆功能&#34;&gt;记忆功能&lt;/h4&gt;&lt;p&gt;面对一些反复调用的函数，提高处理的性能，通过内存换取时间时一个常用的方法，遇到同样的参数无需重复运行即可直接返回计算结果。当然这是在纯函数的前提下&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isEvenNumber&lt;/span&gt;(number: Int): Boolean {   println(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;isEvenNumber&amp;#34;&lt;/span&gt;)   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; number % &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;}&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#a6e22e&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;R&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;memoizeFun&lt;/span&gt;(fn: (X) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; R): (X) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; R {   &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; cache: MutableMap&amp;lt;X, R&amp;gt; = HashMap()   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; {       cache.getOrPut(&lt;span style=&#34;color:#66d9ef&#34;&gt;it&lt;/span&gt;, { fn(&lt;span style=&#34;color:#66d9ef&#34;&gt;it&lt;/span&gt;) })   }}&lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {   &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; m2 = memoizeFun { x: Int &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; isEvenNumber(x) }   &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; rm21 = m2(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)   &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; rm22 = m2(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)   &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; rm23 = m2(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)   println(rm21)   println(rm22)   println(rm23)}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;语言库实现最佳体现&#34;&gt;语言库实现最佳体现&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;val ints = listOf(1, 2, 3, 4, 5, 6)val strings = listOf(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.筛选&lt;/p&gt;&lt;pre&gt;&lt;code&gt;val list1 = ints.filter { it != 2 } println(&amp;quot;filter:$list1&amp;quot;)  val list2 = ints.filterNot { it != 2 } println(&amp;quot;filterNot:$list2&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.映射&lt;/p&gt;&lt;pre&gt;&lt;code&gt;val mlist = strings.map { s -&amp;gt; &amp;quot;hello $s&amp;quot; }println(&amp;quot;map:$mlist&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.折叠&lt;/p&gt;&lt;pre&gt;&lt;code&gt;var sum = ints.reduce { acc, i -&amp;gt; acc + i } println(&amp;quot;Sum:$sum&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;函数式编程应用于ui的发展&#34;&gt;函数式编程应用于UI的发展&lt;/h4&gt;&lt;p&gt;不同平台相同的趋势，由命令式转向声明式，甚至不同平台之间的视图函数和函数中参数的设置都极其相似。1.React&lt;/p&gt;&lt;p&gt;2.Flutter&lt;/p&gt;&lt;p&gt;3.SwiftUI&lt;/p&gt;&lt;p&gt;4.Android Compose&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>找回旧时玩代码的感觉</title>
       <link>https://wooi.github.io/posts/reborn/</link>
       <pubDate>Fri, 26 Mar 2021 20:45:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/reborn/</guid>
       <description>&lt;h1 id=&#34;找回旧时玩代码的感觉&#34;&gt;找回旧时玩代码的感觉&lt;/h1&gt;&lt;p&gt;上一次提交的博客还在2017年，虽然这几年间偶尔会做一些自己感兴趣的side project，但是基本上没有话费太多时间精力在这些项目上。其中一个应用在 Google play 上架一段时间，半年时间盈利200美金，还有一个用户通过我的反馈邮箱找到了我的PayPle账号，很意外的收到了5美元的PayPle捐款，后面服务器厂商跑路了，碍于某些不可抗因素，再三考虑还是放弃了这个这个项目，我自己把APP在商店下了架。于此同时谷歌商店政策在不断变化，更早之前的一些应用也放弃了维护，现在我的Google Play账号下都是空的。&lt;/p&gt;&lt;p&gt;这数年间见证了公司项目从零到千万月活的每一个脚步，工作开发任务多，这些任务基本上占据了我大部分的精力。农历一直思考，回顾过去，我发现我缺少某些东西，之前为止心里向往的被其他东西给代替了。其中最让我感到失落的是我好像失去了寻找创作力的热情。看了不同的书，看了不同的电影，听了不同的音乐，看了不同的代码，发现好东西当然会相当愉悦，会去羡慕那些作者的创作力，我也想那样，也仅仅只是想而已。&lt;/p&gt;&lt;p&gt;今天周五啊，下班回来先把自己的给敲碎，在这一篇Blog开始，开始追寻我的创作激情和创作力。&lt;/p&gt;&lt;p&gt;先立个Flag，把过去看的书做一些回顾了整理，重新输出一些Blog，还有开始我下一个Side Project。&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>Scala 语言开发Andorid ，开发环境的搭建(二)</title>
       <link>https://wooi.github.io/posts/scala_android_sby2/</link>
       <pubDate>Tue, 17 Jan 2017 13:12:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/scala_android_sby2/</guid>
       <description>&lt;h1 id=&#34;scala-语言开发andorid-开发环境的搭建二&#34;&gt;Scala 语言开发Andorid ，开发环境的搭建(二)&lt;/h1&gt;&lt;h2 id=&#34;什么是-sbt-&#34;&gt;什么是 sbt ？&lt;/h2&gt;&lt;p&gt;上一篇文章介绍过，sbt 就是和 maven ，ant 类似的自动构建工具。那 sbt 有什么优势呢？&lt;/p&gt;&lt;ol&gt;&lt;li&gt;相对其他构建工具更快的编译速度，只编译修改过的文件以及引用的第三方库依赖&lt;/li&gt;&lt;li&gt;triggered execution 特性方便做测试驱动的开发&lt;/li&gt;&lt;li&gt;依据类和依赖使用 Scala 的解析器&lt;/li&gt;&lt;li&gt;sbt 是基于 Scala ，所以可以灵活的使用 Scala 构建工程&lt;/li&gt;&lt;li&gt;支持 java 和 Scala 的混合编程&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&#34;基本目录&#34;&gt;基本目录&lt;/h2&gt;&lt;p&gt;工程的根目录下的文件和文件夹，下面看看文件夹里面到底是什么东西。&lt;/p&gt;&lt;h3 id=&#34;源码&#34;&gt;源码&lt;/h3&gt;&lt;p&gt;根下的 src 目录就是存放源码文件的地方呢&lt;/p&gt;&lt;pre&gt;&lt;code&gt;src/  main/    resources/       &amp;lt;files to include in main jar here&amp;gt;    scala/       &amp;lt;main Scala sources&amp;gt;    java/       &amp;lt;main Java sources&amp;gt;  test/    resources       &amp;lt;files to include in test jar here&amp;gt;    scala/       &amp;lt;test Scala sources&amp;gt;    java/       &amp;lt;test Java sources&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sbt-配置文件&#34;&gt;sbt 配置文件&lt;/h3&gt;&lt;p&gt;在一个小项目中一两个 sbt 文件已经足够了，当时随着项目的扩展有可能要同时管理多个 sbt 文件&lt;/p&gt;&lt;p&gt;一般情况下我们习惯使用 build.sbt 作为文件的名称，当然你也可以使用任何的名字。&lt;/p&gt;&lt;p&gt;根目录下的 sbt 文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;build.sbtproject/  plugin.sbt  Build.scala  &amp;lt;Other Scala files&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到这里你可能会还好奇，sbt 和 Scala  的配置文件有什么区别&lt;/p&gt;&lt;p&gt;一般推荐，sbt 文件作为项目的主要设定文件，而 scala 用于设置第三方依赖或者版本信息等&lt;/p&gt;&lt;h2 id=&#34;编写buildsbt&#34;&gt;编写build.sbt&lt;/h2&gt;&lt;p&gt;下面一步一步写出项目到build.sbt 文件&lt;/p&gt;&lt;h3 id=&#34;表达式&#34;&gt;表达式&lt;/h3&gt;&lt;p&gt;在我们的定义文件了，我们只需要关注设置的表达式&lt;/p&gt;&lt;p&gt;下面的实例显示了项目版本号命名等基本信息，还有 项目中使用的 Scala 版本的配置信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;name := &amp;quot;scala-on-android&amp;quot;organization := &amp;quot;com.fortysevendeg&amp;quot;organizationName := &amp;quot;47 Degrees&amp;quot;organizationHomepage := Some(new URL(&amp;quot;http://47deg.com&amp;quot;))version := 0.1.0scalaVersion := 2.11.6&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不难发现上面的例子 使用 := 作为连接符&lt;/p&gt;&lt;p&gt;另外还可以使用其他的连接符+= 添加多一个元素++= 添加多个元素例如&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;scalacOptions ++= Seq(&amp;quot;-feature&amp;quot;, &amp;ldquo;-deprecation&amp;rdquo;)&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;添加第三方库依赖&#34;&gt;添加第三方库依赖&lt;/h3&gt;&lt;p&gt;和 gradle 一样，其实库的添加分两种一是添加本地 jar 包二是添加远程仓库库&lt;/p&gt;&lt;h4 id=&#34;添加-jar-包&#34;&gt;添加 jar 包&lt;/h4&gt;&lt;p&gt;使用 jar 包最简单到方式是直接把 jar 放到下面目录，这样项目就会自动导入 jar 包&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;/src/main/libs&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;除此之外还能使用自定义到路径&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;unmanagedBase := baseDirectory.value / &amp;ldquo;custom_lib&amp;rdquo;&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&#34;远程依赖&#34;&gt;远程依赖&lt;/h4&gt;&lt;p&gt;远程依赖使用是 ivy 到远程管理仓库，同样你可以使用 += 或者 ++= 到导入一个或多个依赖先看看导入一个到基本表达式&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;libraryDependencies += groupID % artifactID % revision [% configuration]&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;导入多个&lt;/p&gt;&lt;pre&gt;&lt;code&gt;libraryDependencies ++= Seq(  aar(&amp;quot;com.android.support&amp;quot; %  &amp;quot;cardview-v7&amp;quot; % &amp;quot;22.0.0&amp;quot;),  aar(&amp;quot;com.android.support&amp;quot; % &amp;quot;appcompat-v7&amp;quot; % &amp;quot;22.0.0&amp;quot;),  aar(&amp;quot;com.android.support&amp;quot; % &amp;quot;recyclerview-v7&amp;quot; % &amp;quot;22.0.0&amp;quot;),  aar(&amp;quot;com.google.android.gms&amp;quot; % &amp;quot;play-services-base&amp;quot; % &amp;quot;6.5.87&amp;quot;),  &amp;quot;com.typesafe.play&amp;quot; %% &amp;quot;play-json&amp;quot; % &amp;quot;2.3.6&amp;quot;,  &amp;quot;org.specs2&amp;quot; %% &amp;quot;specs2-core&amp;quot; % &amp;quot;2.4.15&amp;quot; % &amp;quot;test&amp;quot;,  &amp;quot;org.specs2&amp;quot; % &amp;quot;specs2-mock_2.11&amp;quot; %  &amp;quot;3.0-M2&amp;quot; % &amp;quot;test&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面可见，可以使用 % 作为分割符，那 %% 又代表上面意思呢。其实为何配合不同版本的 scala ，需要不同依赖， %% 就是解决这个问题的，例如上面的 &amp;ldquo;org.specs2&amp;rdquo; %% &amp;ldquo;specs2-core&amp;rdquo;  sbt 构建工具就根据不同情况选择合适的 org.specs2 或者 specs2-core 库。&lt;/p&gt;&lt;h3 id=&#34;添加-sbt-插件&#34;&gt;添加 sbt 插件&lt;/h3&gt;&lt;p&gt;在目录 project 下有一个 plugin.sbt 文件，只需要 配置相关的信息就能方便安装对应的插件。为了更加方便使用 sbt 管理我们的 Android 工程，可以使用一些插件让开发过程中更加方便，这里说一个常用的插件&lt;a href=&#34;https://github.com/scala-android/sbt-android&#34;&gt;sbt-android&lt;/a&gt;,详细使用和配置的可以看开发文档。这里只演示如何最快的安装。只需要在 plugin.sbt 添加一行便可以完成安装&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;addSbtPlugin(&amp;ldquo;org.scala-android&amp;rdquo; % &amp;ldquo;sbt-android&amp;rdquo; % &amp;ldquo;1.7.1&amp;rdquo;)&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;接着在 根目录下的 build.sbt 中使用我们的插件&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;android.Plugin.androidBuild&lt;br&gt;platformTarget in Android := &amp;ldquo;android-21&amp;rdquo;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这样遍可以使用这个插件提供的一些功能，例如 compile（编译），android:run（运行），android:package-release（打包）等操作。&lt;/p&gt;&lt;p&gt;此外插件还提供了打包的配置方案如下面设置签名文件的路径等信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;packageRelease &amp;lt;&amp;lt;= (packageRelease in Android).dependsOn(setDebugTask(false))apkSigningConfig in Android := Option(  PromptPasswordsSigningConfig(    keystore = new File(Path.userHome.absolutePath + &amp;quot;/.android/signed.keystore&amp;quot;),    alias = &amp;quot;my-password&amp;quot;))&lt;/code&gt;&lt;/pre&gt;</description>
     </item>
   
     <item>
       <title>Scala 语言开发Andorid ，开发环境的搭建(一)</title>
       <link>https://wooi.github.io/posts/scala_android_sby/</link>
       <pubDate>Tue, 10 Jan 2017 21:43:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/scala_android_sby/</guid>
       <description>&lt;h1 id=&#34;scala-语言开发andorid-开发环境的搭建一&#34;&gt;Scala 语言开发Andorid ，开发环境的搭建(一)&lt;/h1&gt;&lt;p&gt;厌倦 Java 繁琐的语法，为了更优雅的开发 Android 程序，Scala 代替 Java 是一个不错的尝试。 开发前可以学习 Scala 的基本语法，某些部分和 Java 非常类似，但又聚合了其他先进语言的特性。与 Java 不同的是，在你熟悉函数式编程的情况下能写出更加优雅的代码。&lt;/p&gt;&lt;h2 id=&#34;sbt-构建工具&#34;&gt;SBT 构建工具&lt;/h2&gt;&lt;p&gt;现在绝大多数的 Android 开发者是官方提供的 Android Studio ，这个 IDE 使用的是基于 Gradle 的自动化建构工具，通过 Gradle 可以配置 Project 各种参数，生产 APK 等操作。SBT 是和 Gradle,Ant,Maven 一样的自动化建构工具，SBT 方便管理我们用 Scala 编写的 Android 工程。&lt;/p&gt;&lt;p&gt;和使用 Java 开发 Andoird 一样，首先要安装 Scala， &lt;a href=&#34;http://scala-lang.org/download/&#34;&gt;下载&lt;/a&gt; 官方文件，在此之前先确定电脑已经安装配置好 Java 环境。如果 macOS 已经安装有 Homebrew 只需要一行代码即可安装配置成功&lt;/p&gt;&lt;pre&gt;&lt;code&gt;brew install scala&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着安装 SBT 同一也一行代码搞定(赶紧换一台 mac 吧~~&lt;/p&gt;&lt;pre&gt;&lt;code&gt;brew install sbt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他系统的配置大可直接看 [Scala]((&lt;a href=&#34;http://scala-lang.org/&#34;&gt;http://scala-lang.org/&lt;/a&gt;) 和 &lt;a href=&#34;http://www.scala-sbt.org/index.html&#34;&gt;SBT&lt;/a&gt; 官网，里边有详细的安装配置教程&lt;/p&gt;&lt;h2 id=&#34;项目结构&#34;&gt;项目结构&lt;/h2&gt;&lt;p&gt;和使用 构建工具一样，Gradle 有一种固定的文件分类方式，不同的文件夹安放不同类型的文件。同样的，SBT 也是有固定的文件结构。其实 SBT 的结构和 Gradle 的结构类似。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scala-android/|- project/|  |- plugins.sbt |- src/|  |- main/|     |- assets/|     |- java/|     |- res/|        |- layout/|           |- main.xml|        |- values/|           |- strings.xml|     |- scala/|        |- com/|           |- fortysevendeg/|              |- scala/|                 |- android/|                    |- SampleActivity.scala/|     |- AndroidManifest.xml|  |- test/|     |- java/|     |- res/|     |- scala/|- build.sbt&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;结构文件&#34;&gt;结构文件&lt;/h2&gt;&lt;p&gt;根目录下，src 文件夹内存放的有源码的文件，布局文件，以及另外一些资源文件。java 文件存放的是 java的源代码文件，scala文件夹里存放的当然是 scala 源代码文件，和 java 编写的结构一样，倒序域名包命名的管理方式。text存放的是测试文件。&lt;/p&gt;&lt;p&gt;build.sbt 和 app 中Gradle build  文件类似，可以配置一些项目信息，例如管理包名，应用名，编译的目标版本，最低限制版本，开启混淆的。使用的语法与 gradle 的语法略有不同。下面是一些常用的配置信息。&lt;strong&gt;build.sbt&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 申明使用 Android 插件，让构造工具知道这是一个Android 工程android.Plugin.androidBuild​    // 生命 Android 目标 API platformTarget in Android := &amp;quot;android-21&amp;quot;// 应用名name := &amp;quot;&amp;quot;&amp;quot;scala-android&amp;quot;&amp;quot;&amp;quot;// 应用版本号version := &amp;quot;1.0.0&amp;quot;// Scala 版本scalaVersion := &amp;quot;2.11.4&amp;quot;// 项目中依赖的库resolvers += Resolver.jcenterRepolibraryDependencies ++=  &amp;quot;com.android.support&amp;quot; % &amp;quot;cardview-v7&amp;quot; % supportLibsVersion ::  &amp;quot;com.android.support&amp;quot; % &amp;quot;customtabs&amp;quot; % supportLibsVersion ::  &amp;quot;com.android.support&amp;quot; % &amp;quot;design&amp;quot; % supportLibsVersion ::  &amp;quot;com.android.support&amp;quot; % &amp;quot;gridlayout-v7&amp;quot; % supportLibsVersion ::  &amp;quot;com.android.support&amp;quot; % &amp;quot;preference-v14&amp;quot; % supportLibsVersion ::  &amp;quot;com.futuremind.recyclerfastscroll&amp;quot; % &amp;quot;fastscroll&amp;quot; % &amp;quot;0.2.5&amp;quot; ::  &amp;quot;com.evernote&amp;quot; % &amp;quot;android-job&amp;quot; % &amp;quot;1.1.4&amp;quot; ::  &amp;quot;com.github.jorgecastilloprz&amp;quot; % &amp;quot;fabprogresscircle&amp;quot; % &amp;quot;1.01&amp;quot; ::  &amp;quot;com.google.android.gms&amp;quot; % &amp;quot;play-services-ads&amp;quot; % playServicesVersion ::  &amp;quot;com.google.android.gms&amp;quot; % &amp;quot;play-services-analytics&amp;quot; % playServicesVersion ::  &amp;quot;com.google.android.gms&amp;quot; % &amp;quot;play-services-gcm&amp;quot; % playServicesVersion ::// 开启 Scala 混淆proguardScala in Android := true// 开启 Android 混淆useProguard in Android := true// 设置混淆规则proguardOptions in Android ++= Seq(  &amp;quot;-ignorewarnings&amp;quot;,  &amp;quot;-keep class scala.Dynamic&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;project/plugins.sbt文件是项目中构建工具使用到的插件&lt;strong&gt;project/plugins.sbt&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;addSbtPlugin(&amp;quot;org.scala-android&amp;quot; % &amp;quot;sbt-android&amp;quot; % &amp;quot;1.7.2&amp;quot;)addSbtPlugin(&amp;quot;com.timushev.sbt&amp;quot; % &amp;quot;sbt-updates&amp;quot; % &amp;quot;0.1.10&amp;quot;)addSbtPlugin(&amp;quot;net.virtual-void&amp;quot; % &amp;quot;sbt-dependency-graph&amp;quot; % &amp;quot;0.8.2&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
     </item>
   
     <item>
       <title>爛的故事（二）</title>
       <link>https://wooi.github.io/posts/badstory2/</link>
       <pubDate>Wed, 21 Dec 2016 17:35:57 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/badstory2/</guid>
       <description>&lt;h1 id=&#34;爛的故事二&#34;&gt;爛的故事（二）&lt;/h1&gt;&lt;p&gt;寒冷的平安夜下著雪，路上的行人匆匆而過。街角的小女孩還沒賣出一盒火柴。一次次冷漠的拒絕意味著她今晚不會有任何收入。心灰意冷的小女孩划動了一根火柴，燃燒的火柴讓她感到十分溫暖。接著又用凍僵的小手點燃了另一根火柴，這樣一根接著一根。她拿著最後一根火柴，火焰慢慢地慢慢地變得微弱直至熄滅。心滿意足的小女孩才上了她僕人開來的車，開開心心的回家吃聖誕大餐。&lt;/p&gt;&lt;p&gt;劇終&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>ImageView的使用笔记</title>
       <link>https://wooi.github.io/posts/imageviwe_note/</link>
       <pubDate>Mon, 28 Nov 2016 11:20:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/imageviwe_note/</guid>
       <description>&lt;h3 id=&#34;一使用imageview-的src-和background&#34;&gt;一、使用ImageView 的src 和background&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;src ：原图大小，不被拉伸;&lt;br&gt;background：为Imageview的背景，根据ImageView给长宽进行拉伸；&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;二设置imageview的透明度&#34;&gt;二、设置Imageview的透明度&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;android:src在设置ImageView的setAlpha(int alpha)时，起作用;&lt;br&gt;android:background在设置ImageView的setAlpha(int alpha)时，不起作用;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;mImageView.setBackgroundDrawable(mDrawable.mutate());mImageView.getBackground().setAlpha(100);&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;三设置imageview的前景foreground&#34;&gt;三、设置ImageView的前景（foreground）&lt;/h3&gt;&lt;p&gt;有时候设计需要在ImageView 上面覆盖一层（如灰色）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;View 提供了一个setForeground(Drawable foreground)&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;四使用imageview的androidadjustviewbounds&#34;&gt;四、使用ImageView的“android:adjustViewBounds”&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;如果想设置图片固定大小，又想保持图片宽高比，需要如下设置：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;设置setAdjustViewBounds为true；&lt;/li&gt;&lt;li&gt;设置maxWidth、MaxHeight；&lt;/li&gt;&lt;li&gt;设置设置layout_width和layout_height为wrap_content&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&#34;五正确使用imageview的androidscaletype&#34;&gt;五、正确使用ImageView的“android:scaleType”&lt;/h3&gt;&lt;p&gt;ImageView的“android:scaleType”属性是对src才有效的&lt;/p&gt;&lt;p&gt;ScaleDrawable类是afc框架中提供了一个专门处理Drawable scale的类，在ImageView的ScaleType的基础上额外提供了11中裁剪方式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;（1）CROP_CENTER（2）CROP_START（3）CROP_END（4）FIT_CENTER（5）FIT_START（6）FIT_END（7）MATCH_WIDTH_TOP（8）MATCH_WIDTH_BOTTOM（9）MATCH_WIDTH_CENTER（10）CENTER（11）CROP_BY_PIVOT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://images.thoughtbot.com/blog-vellum-image-uploads/wDbiaqGSQyyErtXGSh6w_scaletype.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;要保证ScaleDrawable.CROP_START属性设置成功，在xml中一定要设置“android:scaleType=”fitXY”&lt;/p&gt;&lt;/blockquote&gt;</description>
     </item>
   
     <item>
       <title>Android 内存泄露的几中场景</title>
       <link>https://wooi.github.io/posts/memory_leak/</link>
       <pubDate>Tue, 22 Nov 2016 13:57:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/memory_leak/</guid>
       <description>&lt;h1 id=&#34;android-内存泄漏&#34;&gt;Android 内存泄漏&lt;/h1&gt;&lt;p&gt;java 存在一个垃圾回收机制，发生泄漏的原因就是应该被回收的垃圾没有被回收，这种情况就叫做内存泄漏&lt;/p&gt;&lt;p&gt;解决内存泄漏的方法的思路：让不易回收的内存可以在不需要继续使用单情况下被系统回收掉。&lt;/p&gt;&lt;p&gt;怎么做在能让某些内存可以被及时回收呢？这里就需要了解 java 的一个知识点，这就是引用类型。java 分 &lt;a href=&#34;https://segmentfault.com/a/1190000003910496&#34;&gt;四 种引用类型&lt;/a&gt;，分别是：强引用，软引用，弱引用，虚引用。这从这四种引用点名称可以推测，系统对于不用类型引用有不同的回收机制。为方便对比列出下方的表格&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;引用类型&lt;/th&gt;&lt;th&gt;回收条件&lt;/th&gt;&lt;th&gt;发生泄漏可能性&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;强引用&lt;/td&gt;&lt;td&gt;不回收&lt;/td&gt;&lt;td&gt;可能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;软引用&lt;/td&gt;&lt;td&gt;内存不足时回收&lt;/td&gt;&lt;td&gt;不可能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;弱引用&lt;/td&gt;&lt;td&gt;一定回收&lt;/td&gt;&lt;td&gt;不可能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;虚引用&lt;/td&gt;&lt;td&gt;不回收&lt;/td&gt;&lt;td&gt;可能&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;合理点使用不同的引用类型，可以避免出现内存泄露的情况&lt;/p&gt;&lt;p&gt;在Android开发中，出现内存泄露我认为可以分为两大部分，一部分是 java 相关的，另一部分是 Android Api使用容易出现内存泄露&lt;/p&gt;&lt;p&gt;常见有以下场景&lt;/p&gt;&lt;h5 id=&#34;1-单例模式&#34;&gt;1. 单例模式&lt;/h5&gt;&lt;p&gt;单例模式生成的静态对象因为生命周期和应用的进程一致，一般只有当应用退出或者运行的进程被结束，对象才能结束对象的生命周。例如当一个单例对象引用一个 activity 变量，即便 activity 可能已经退出了，但是因为单例对象还持有 activity ，所以系统不能回收这个 activity 造成了内存泄露&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;&lt;br&gt;使用弱应用，例如&lt;br&gt;private WeakReference&lt;!-- raw HTML omitted --&gt; wr = null;&lt;br&gt;wr = new WeakReference&lt;!-- raw HTML omitted --&gt;(myActivity);&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&#34;2-匿名内部类使用threads--timertasks&#34;&gt;2. 匿名内部类使用(Threads , TimerTasks)&lt;/h5&gt;&lt;p&gt;非静态内部类，匿名类阅读，可以轻易访问外围类的变量，也就是说匿名内部类可以持有外部类的的变量，当外部类的变量可以被回收的时候，当时因为内部类持有外部类的引用，这样就造成了内存泄露。但是静态内部类就不会引用外部变量&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;&lt;br&gt;1.使用静态内部类&lt;br&gt;2.用弱引用就是引用到的变量&lt;br&gt;3.可以的话，在结束外部类时及时关闭匿名内部类(Thread)&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&#34;3-context-的使用&#34;&gt;3. context 的使用&lt;/h5&gt;&lt;p&gt;Context 是 Android 开发中经常传递的变量，但是某些情况下本该被回收的 Context 却因为某些对象依然持有 Context 的引用，进而发生内存泄露&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;&lt;br&gt;1.使用 ApplicationContext 代替 Context ，因为 ApplicationContext 的生命周期和应用(进程)一样长。&lt;br&gt;2.对于 Context 变量慎用 Static 修饰，&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&#34;4-handler-的使用&#34;&gt;4. handler 的使用&lt;/h5&gt;&lt;p&gt;Handler 用于延时的一个作用，熟悉 Handler 机制的都应该清楚，我们会把一下需要的一些操作放在 Messagequeue 里面，等待 用户的 handler 对象按队列顺序发送消息。&lt;/p&gt;&lt;p&gt;会存在这样一个场景，当一个 Activity 需要销毁，但是 MessageQueue 还存在一些消息为处理，消息持有 Handler 引用，Handler 持有外部类的引用，这时 Activity 就无法正常回收了。这种情况和非静态内部类引起的原因差不多。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;&lt;br&gt;1.把 Handler 实现做一个独立的类或者使用静态修饰&lt;br&gt;2.在 Handler 内部调用到 acivity 等外部变量是可以用弱引用修饰作为 activity 引用类型&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&#34;5-cursor-bitmap-stream-没及时释放&#34;&gt;5. Cursor Bitmap Stream 没及时释放&lt;/h5&gt;&lt;p&gt;打开资源文件，会把文件缓存在内存和 jvm 虚拟机中，在使用结束后如果没有 close() 则会发生内存泄露。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;&lt;br&gt;1.使用结束后及时调用 close()&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&#34;6-监听器的没及时注销sensor-manager&#34;&gt;6. 监听器的没及时注销(Sensor Manager)&lt;/h5&gt;&lt;p&gt;Android 系统提供了一些服务，要获取这些服务的对象都要使用到 Context 这个变量当一个 activity 关闭后，这些系统级别的服务都会继续持有 Context 引用&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;&lt;br&gt;1.在退出 Activity 后及时注销监听器&lt;br&gt;2.使用 ApplicationContext 代替 Context&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&#34;7-listview-的-adpater-没使用-convertview-缓存&#34;&gt;7. listView 的 adpater 没使用 ConvertView 缓存&lt;/h5&gt;&lt;p&gt;ListView 会缓存一部分 View ，没用使用 getview() 里面的参数 ConvertView&lt;/p&gt;&lt;h5 id=&#34;8-静态集合对象没有清理&#34;&gt;8. 静态集合对象没有清理&lt;/h5&gt;&lt;p&gt;静态集合里数据多，生命周期与应用一样长，但是依然占据了一部分内存，不需要时没有进行清理的动作&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;&lt;br&gt;1.退出后 clear 掉集合里面的所有数据，然后赋值 null&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&#34;9-webview-没有及时释放&#34;&gt;9. webview 没有及时释放&lt;/h5&gt;&lt;p&gt;webview 使用完毕后一样需要 destroy 掉，否者一直常驻内存&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;解决方案&lt;/em&gt;&lt;br&gt;因为 webView 耗费大量内存，可以为 WebView 分配一个独立的线程，也主线程做通讯。不需要时也要记得销毁掉。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 id=&#34;10监听器&#34;&gt;10.监听器&lt;/h5&gt;&lt;p&gt;使用监听者模式，我们会添加一些监听器，但是移除被监听对象时，往往忘记取消设置的监听器&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>AIDL 官方使用介绍</title>
       <link>https://wooi.github.io/posts/android_interface_definition_language/</link>
       <pubDate>Mon, 21 Nov 2016 16:51:24 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/android_interface_definition_language/</guid>
       <description>&lt;h1 id=&#34;android-interface-definition-language-aidl&#34;&gt;Android Interface Definition Language (AIDL)&lt;/h1&gt;&lt;p&gt;AIDL是允许你完成自定义接口，用于不同进程中服务器和客户端之间的通讯。主要是因为Android不允许你直接跨进程间传递消息，所以需要通过AIDL把传递的对象分解包装为操作系统可以接受的对象。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当你的Service提供跨进程通讯，而且在服务中做多线程处理时你可以使用AIDL。如果当前的Service不准备提供给其他进程服务端做访问你只需要在服务中实现自定义的binder即可。或者你想实现IPC（进程间通讯），Service内又不需要做多线程管理，这种情况下你只要使用Messager。当然要合理选择哪一种方式的前提是你清楚了解如何绑定一Service；&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;设计AIDL接口时，要知道你在什么情景下才需要调用你这个接口&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果只是本地进程中调用这个接口，完全没必要使用AIDL,这时候只要在服务中实现binder即可&lt;/li&gt;&lt;li&gt;提供接口给远程进程，这时候可能接受远程中不同的线程访问你的接口，换句话说，你要在你的接口中保证线程的安全&lt;/li&gt;&lt;li&gt;The oneway keyword modifies the behavior of remote calls. When used, a remote call does not block; it simply sends the transaction data and immediately returns. The implementation of the interface eventually receives this as a regular call from the Binder thread pool as a normal remote call. If oneway is used with a local call, there is no impact and the call is still synchronous.&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;定义aidl接口&#34;&gt;定义AIDL接口&lt;/h2&gt;&lt;p&gt;使用java语法在源码目录中创建你的 &lt;em&gt;.aidl&lt;/em&gt; 文件&lt;/p&gt;&lt;p&gt;当你在应用中创建了 &lt;em&gt;.aidl&lt;/em&gt; 文件，Android SDK tools 会基于这个文件自动为我们在 &lt;em&gt;gen/&lt;/em&gt; 目录中生成IBinder对象。这样客户端就可以通过IBinder实现IPC通讯&lt;/p&gt;&lt;p&gt;通过AIDL绑定服务的如下步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;创建 &lt;em&gt;.aidl&lt;/em&gt; 文件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实现接口&lt;/p&gt;&lt;p&gt;文件自动创建接口文件，内部Stub类必须继承Binder，实现Stubd方法内的行为&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对客户端暴露接口&lt;/p&gt;&lt;p&gt;实现的Service重写 onBind()方法 返回你实现的stub类&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;aidl文件的做了任何的改变，切记修改使用你服务的客户端&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;1创建-aidl-文件&#34;&gt;1.创建 &lt;em&gt;.aidl&lt;/em&gt; 文件&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;IRemoteService.aidl&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// IRemoteService.aidlpackage com.example.administrator.aidl.AIDL;import com.example.administrator.aidl.AIDL.IRemoteServiceCallback;// Declare any non-default types here with import statementsinterface IRemoteService {    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    void registerCallback(IRemoteServiceCallback cb);    void unregisterCallback(IRemoteServiceCallback cb);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;ISecondary.aidl&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// ISecondary.aidlpackage com.example.administrator.aidl.AIDL;// Declare any non-default types here with import statementsinterface ISecondary {    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    int getPid();}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;IRemoteServiceCallback.aidl&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// IRemoteServiceCallback.aidlpackage com.example.administrator.aidl.AIDL;// Declare any non-default types here with import statementsinterface IRemoteServiceCallback {    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    void valueChanged(int value);}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;实现-aidl-文件中的接口如实现-iremoteserviceaidl-和-isecondaryaidl-接口&#34;&gt;实现 &lt;em&gt;.aidl&lt;/em&gt; 文件中的接口,如实现 &lt;em&gt;IRemoteService.aidl&lt;/em&gt; 和 &lt;em&gt;ISecondary.aidl&lt;/em&gt; 接口&lt;/h3&gt;&lt;p&gt;创建 &lt;em&gt;.aidl&lt;/em&gt; 文件时，Android skd Tool 会自动对应的java文件，其中会生成一个继承Binder抽象内部类 &lt;em&gt;Stub&lt;/em&gt; 。所以在服务中继承Stub，实现自己的内部方法，例如下面RemoteService中 mBinder和mSecondaryBinder中的实现&lt;/p&gt;&lt;h3 id=&#34;暴露你的接口例如在例如下面remoteservice中onbind的方法中把实现的对象返回给客户端程序&#34;&gt;暴露你的接口，例如在例如下面RemoteService中OnBind的方法中，把实现的对象返回给客户端程序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RemoteService&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class RemoteService extends Service {    @Override    public void onCreate() {        super.onCreate();    }    @Nullable    @Override    public IBinder onBind(Intent intent) {        if (IRemoteService.class.getName().equals(intent.getAction())) {            return mBinder;        }        if (ISecondary.class.getName().equals(intent.getAction())) {            return mSecondaryBinder;        }        return null;    }    private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {        @Override        public void registerCallback(IRemoteServiceCallback cb) throws RemoteException {                cb.valueChanged(mSecondaryBinder.getPid());        }        @Override        public void unregisterCallback(IRemoteServiceCallback cb) throws RemoteException {        }    };    private final ISecondary.Stub mSecondaryBinder = new ISecondary.Stub() {        @Override        public int getPid() throws RemoteException {            return Process.myPid();        }    };}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;绑定方法如同bind方法一样bindserviceintent-mconnection-contextbind_auto_create&#34;&gt;绑定方法如同bind方法一样，bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class Binding extends Activity {    private static final int BUMP_MSG = 1;    TextView mCallbackText;    IRemoteService mService;    Button mKillButton;    Boolean mIsBound;    ISecondary mSecondaryService;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.aidl_layout);        Button bindbutton = (Button) findViewById(R.id.bind);        bindbutton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Intent intent = new Intent(Binding.this, RemoteService.class);                intent.setAction(IRemoteService.class.getName());                bindService(intent, mConnection, Context.BIND_AUTO_CREATE);                intent.setAction(ISecondary.class.getName());                bindService(intent, mSecondaryConnection, Context.BIND_AUTO_CREATE);                mCallbackText.setText(&amp;quot;Binding.&amp;quot;);                mIsBound = true;            }        });        Button unbindbutton = (Button) findViewById(R.id.unbind);        unbindbutton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                if (mIsBound) {                    if (mService != null) {                        try {                            mService.unregisterCallback(mCallback);                        } catch (RemoteException e) {                            e.printStackTrace();                        }                        unbindService(mConnection);                        mKillButton.setEnabled(false);                        mIsBound = false;                        mCallbackText.setText(&amp;quot;Unbinding&amp;quot;);                    }                }            }        });        mKillButton = (Button) findViewById(R.id.kill);        mKillButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                if (mSecondaryService != null) {                    try {                        int pid = mSecondaryService.getPid();                        Process.killProcess(pid);                        mCallbackText.setText(&amp;quot;Killed service process.&amp;quot;);                    } catch (RemoteException e) {                        e.printStackTrace();                        Toast.makeText(Binding.this,                                R.string.remote_call_failed,                                Toast.LENGTH_SHORT).show();                    }                }            }        });        mKillButton.setEnabled(false);        mCallbackText = (TextView) findViewById(R.id.callback);        mCallbackText.setText(&amp;quot;Not attached.&amp;quot;);    }    private ServiceConnection mConnection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {            Log.e(&amp;quot;TAG&amp;quot;,&amp;quot;connected&amp;quot;);            mService = IRemoteService.Stub.asInterface(iBinder);            mKillButton.setEnabled(true);            mCallbackText.setText(&amp;quot;Attached&amp;quot;);            try {                mService.registerCallback(mCallback);            } catch (RemoteException e) {                e.printStackTrace();            }            Toast.makeText(Binding.this, R.string.remote_service_connected,                    Toast.LENGTH_SHORT).show();        }        @Override        public void onServiceDisconnected(ComponentName componentName) {            mService = null;            mKillButton.setEnabled(false);            mCallbackText.setText(&amp;quot;Disconnected.&amp;quot;);        }    };    private ServiceConnection mSecondaryConnection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {            mSecondaryService = ISecondary.Stub.asInterface(iBinder);            mKillButton.setEnabled(true);        }        @Override        public void onServiceDisconnected(ComponentName componentName) {            mSecondaryService = null;            mKillButton.setEnabled(false);        }    };    private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() {        @Override        public void valueChanged(int value) throws RemoteException {            mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0));        }    };    private Handler mHandler = new Handler() {        @Override        public void handleMessage(Message msg) {            switch (msg.what) {                case BUMP_MSG:                    mCallbackText.setText(&amp;quot;Received from service: &amp;quot; + msg.arg1);                    break;                default:                    super.handleMessage(msg);            }        }    };    @Override    protected void onDestroy() {        super.onDestroy();        if(mService!=null){            unbindService(mConnection);        }    }}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;ipc传递对象&#34;&gt;IPC传递对象&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;传递的对象实现Parcelable接口&lt;/li&gt;&lt;li&gt;在对象的类中实现 writeToParcel方法&lt;/li&gt;&lt;li&gt;添加一个静态变量CREATOR并且实现Parcelable.Creator 的接口&lt;/li&gt;&lt;li&gt;在目录中添加一个.aidl文件声明上面所创建的parcelable 类,列如如下&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Rect.aidl&lt;/p&gt;&lt;pre&gt;&lt;code&gt;package android.graphics;parcelable Rect;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里创建我们的Rect类，并实现现Parcelable接口，类中再实现writeToParcel方法，静态变量CREATOR&lt;/p&gt;&lt;p&gt;Rect.java&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class Rect implements Parcelable {    public int left;    public int top;    public int right;    public int bottom;    public static final Parcelable.Creator&amp;lt;Rect&amp;gt; CREATOR = new Creator&amp;lt;Rect&amp;gt;() {        @Override        public Rect createFromParcel(Parcel parcel) {            return new Rect(parcel);        }        @Override        public Rect[] newArray(int i) {            return new Rect[i];        }    };    public Rect() {    }    private Rect(Parcel in) {        readFromParcel(in);    }    @Override    public int describeContents() {        return 0;    }    @Override    public void writeToParcel(Parcel parcel, int i) {        parcel.writeInt(left);        parcel.writeInt(top);        parcel.writeInt(right);        parcel.writeInt(bottom);    }    public void readFromParcel(Parcel in) {        left = in.readInt();        top = in.readInt();        right = in.readInt();        bottom = in.readInt();    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 IRemoteService.aidl添加下面的接口&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Rect getRect();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在RemoteService.java中的mBinder对象中实现以下方法，这里我们对服务返回的对象进行赋值&lt;/p&gt;&lt;pre&gt;&lt;code&gt; @Override        public Rect getRect() throws RemoteException {            Rect rect = new Rect();            rect.bottom = 10;            rect.top = 10;            rect.left = 5;            rect.right = 6;            return rect;        }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们便可以在客户端中先服务获取我的对象，具体在Bindnd.java中的mConnection得到Rect对象，如下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   private ServiceConnection mConnection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {            Log.e(&amp;quot;TAG&amp;quot;, &amp;quot;connected&amp;quot;);            mService = IRemoteService.Stub.asInterface(iBinder);            mKillButton.setEnabled(true);            mCallbackText.setText(&amp;quot;Attached&amp;quot;);            try {                //获取到服务端中的Rect对象                android.graphics.Rect rectFromService = mService.getRect();                Log.e(&amp;quot;TAG&amp;quot;,&amp;quot;bottom = &amp;quot;+rectFromService.bottom+&amp;quot;,top = &amp;quot;+rectFromService.top+&amp;quot;,left = &amp;quot;+rectFromService.left+&amp;quot;,right =&amp;quot;+rectFromService.right);                mService.registerCallback(mCallback);            } catch (RemoteException e) {                e.printStackTrace();            }            Toast.makeText(Binding.this, R.string.remote_service_connected,                    Toast.LENGTH_SHORT).show();        }        @Override        public void onServiceDisconnected(ComponentName componentName) {            mService = null;            mKillButton.setEnabled(false);            mCallbackText.setText(&amp;quot;Disconnected.&amp;quot;);        }    };&lt;/code&gt;&lt;/pre&gt;</description>
     </item>
   
     <item>
       <title>Java注解解释</title>
       <link>https://wooi.github.io/posts/annotation/</link>
       <pubDate>Mon, 21 Nov 2016 16:51:24 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/annotation/</guid>
       <description>&lt;p&gt;Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据[1]。Java语言中的类、方法、变量、参数和包等都可以被标注。Java标注和Javadoc不同，标注有自反性。在编译器生成类文件时，标注可以被嵌入到字节码中，由Java虚拟机执行时获取到标注[2]。&lt;/p&gt;&lt;pre&gt;&lt;code&gt; // @Twizzle标注toggle()方法。  @Twizzle  public void toggle() {  }  // 声明Twizzle标注  public @interface Twizzle {  }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;标注可以包含一个关键字和值的对所构成的列表：&lt;/p&gt;&lt;pre&gt;&lt;code&gt; //等同于 @Edible(value = true)  @Edible(true)  Item item = new Carrot();  public @interface Edible {    boolean value() default false;  }  @Author(first = &amp;quot;Oompah&amp;quot;, last = &amp;quot;Loompah&amp;quot;)  Book book = new Book();  public @interface Author {    String first();    String last();  }&lt;/code&gt;&lt;/pre&gt;</description>
     </item>
   
     <item>
       <title>Flask Web开发笔记</title>
       <link>https://wooi.github.io/posts/flask_note/</link>
       <pubDate>Mon, 21 Nov 2016 16:09:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/flask_note/</guid>
       <description>&lt;p&gt;#Flask笔记&lt;/p&gt;&lt;h5 id=&#34;21初始化&#34;&gt;2.1初始化&lt;/h5&gt;&lt;p&gt;Web 服务器使用一种名为 Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。程序实例是 Flask 类的对象&lt;/p&gt;&lt;h5 id=&#34;22-路由和视图函数&#34;&gt;2.2 路由和视图函数&lt;/h5&gt;&lt;p&gt;程序实例需要知道对每个 URL 请求运行哪些代码，所以保存了一个URL到Python 函数的映射关系。处理 URL 和函数之间关系的程序称为路由。&lt;/p&gt;&lt;p&gt;&lt;em&gt;在 Python 代码中嵌入响应字符串会导致代码难以维护&lt;/em&gt;&lt;/p&gt;&lt;h5 id=&#34;23启动服务器&#34;&gt;2.3启动服务器&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;name&lt;/strong&gt;==&#39;&lt;strong&gt;main&lt;/strong&gt;&#39; 是 Python 的惯常用法，在这里确保直接执行这个脚本时才启动开发Web 服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因此不会执行 app.run()。&lt;/p&gt;&lt;p&gt;服务器启动后，会进入轮询，等待并处理请求。轮询会一直运行，直到程序停止，比如按Ctrl-C 键。&lt;/p&gt;&lt;h5 id=&#34;25请求-响应循环&#34;&gt;2.5请求-响应循环&lt;/h5&gt;&lt;p&gt;######2.5.1　程序和请求上下文&lt;/p&gt;&lt;p&gt;Flask 使用上下文临时把某些对象变为全局可访问。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;变量名&lt;/th&gt;&lt;th style=&#34;text-align:center&#34;&gt;上下文&lt;/th&gt;&lt;th style=&#34;text-align:right&#34;&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;current_app&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;程序上下文&lt;/td&gt;&lt;td style=&#34;text-align:right&#34;&gt;当前激活程序的程序实例&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;g&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;程序上下文&lt;/td&gt;&lt;td style=&#34;text-align:right&#34;&gt;处理请求时用作临时存储的对象。每次请求都会重设这个变量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;request&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;请求上下文&lt;/td&gt;&lt;td style=&#34;text-align:right&#34;&gt;请求对象，封装了客户端发出的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;session&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;请求上下文&lt;/td&gt;&lt;td style=&#34;text-align:right&#34;&gt;用户会话，用于存储请求之间需要“记住”的值的词典&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&#34;252请求调度&#34;&gt;2.5.2　请求调度&lt;/h5&gt;&lt;p&gt;程序收到客户端发来的请求时，要找到处理该请求的视图函数。为了完成这个任务，Flask会在程序的 URL 映射中查找请求的 URL。URL 映射是 URL 和视图函数之间的对应关系。Flask 使用 app.route 修饰器或者非修饰器形式的 app.add_url_rule() 生成映射。&lt;/p&gt;&lt;h5 id=&#34;253请求钩子&#34;&gt;2.5.3　请求钩子&lt;/h5&gt;&lt;p&gt;有时在处理请求之前或之后执行代码会很有用&lt;/p&gt;&lt;ul&gt;&lt;li&gt;before_first_request：注册一个函数，在处理第一个请求之前运行。&lt;/li&gt;&lt;li&gt;before_request：注册一个函数，在每次请求之前运行。&lt;/li&gt;&lt;li&gt;after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。&lt;/li&gt;&lt;li&gt;teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。&lt;/li&gt;&lt;/ul&gt;&lt;h5 id=&#34;254响应&#34;&gt;2.5.4　响应&lt;/h5&gt;&lt;p&gt;Flask 调用视图函数后，会将其返回值作为响应的内容。大多数情况下，响应就是一个简单的字符串，作为 HTML 页面回送客户端。&lt;/p&gt;&lt;p&gt;但 HTTP 协议需要的不仅是作为请求响应的字符串。HTTP 响应中一个很重要的部分是状态码，Flask 默认设为 200，这个代码表明请求已经被成功处理。&lt;/p&gt;&lt;h4 id=&#34;31-jinja2模板引擎&#34;&gt;3.1 Jinja2模板引擎&lt;/h4&gt;&lt;h5 id=&#34;311渲染模板&#34;&gt;3.1.1　渲染模板&lt;/h5&gt;&lt;p&gt;Flask 提供的 render_template 函数把 Jinja2 模板引擎集成到了程序中。render_template 函数的第一个参数是模板的文件名&lt;/p&gt;&lt;h5 id=&#34;312变量&#34;&gt;3.1.2　变量&lt;/h5&gt;&lt;p&gt;在模板中使用的 {{ name }} 结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。&lt;/p&gt;&lt;p&gt;Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。在模板&lt;/p&gt;&lt;p&gt;可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量 name 的值：Hello, {{ name|capitalize }}&lt;/p&gt;&lt;h5 id=&#34;313控制结构&#34;&gt;3.1.3　控制结构&lt;/h5&gt;&lt;p&gt;下面这个例子展示了如何在模板中使用条件控制语句：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{% if user %} Hello, {{ user }}!{% else %} Hello, Stranger!{% endif %}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一种常见需求是在模板中渲染一组元素。下例展示了如何使用 for 循环实现这一需求：&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &amp;lt;ul&amp;gt; {% for comment in comments %} &amp;lt;li&amp;gt;{{ comment }}&amp;lt;/li&amp;gt; {% endfor %} &amp;lt;/ul&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Jinja2 还支持宏。宏类似于 Python 代码中的函数。&lt;/p&gt;&lt;p&gt;需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{% include &#39;common.html&#39; %}&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;32使用flask-bootstrap集成twitter-bootstrap&#34;&gt;3.2　使用Flask-Bootstrap集成Twitter Bootstrap&lt;/h5&gt;&lt;p&gt;Bootstrap（http://getbootstrap.com/）是 Twitter 开发的一个开源框架，它提供的用户界面组件可用于创建整洁且具有吸引力的网页，而且这些网页还能兼容所有现代 Web 浏览器。&lt;/p&gt;&lt;h5 id=&#34;33自定义错误页面&#34;&gt;3.3　自定义错误页面&lt;/h5&gt;&lt;p&gt;像常规路由一样，Flask 允许程序使用基于模板的自定义错误页面。最常见的错误代码有两个：404，客户端请求未知页面或路由时显示；500，有未处理的异常时显示。为这两个错误代码指定自定义处理程序的方式如示例 3-6 所示。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;@app.errorhandler(404)def page_not_found(e): return render_template(&#39;404.html&#39;), 404@app.errorhandler(500)def internal_server_error(e): return render_template(&#39;500.html&#39;), 500&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.4　链接在模板中直接编写简单路由的 URL 链接不难，但对于包含可变部分的动态路由，在模板中构建正确的 URL 就很困难。&lt;strong&gt;而且，直接编写 URL 会对代码中定义的路由产生不必要的依赖关系。如果重新定义路由，模板中的链接可能会失效。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了避免这些问题，Flask 提供了 &lt;strong&gt;url_for()&lt;/strong&gt; 辅助函数，它可以使用程序 URL 映射中保存的信息生成 URL。&lt;/p&gt;&lt;h5 id=&#34;35静态文件&#34;&gt;3.5　静态文件&lt;/h5&gt;&lt;p&gt;默认设置下，Flask 在程序根目录中名为 static 的子目录中寻找静态文件。如果需要，可在static 文件夹中使用子文件夹存放文件。&lt;/p&gt;&lt;h5 id=&#34;36使用flask-moment本地化日期和时间&#34;&gt;3.6　使用Flask-Moment本地化日期和时间&lt;/h5&gt;&lt;p&gt;服务器需要统一时间单位，这和用户所在的地理位置无关，所以一般使用协调世界时（Coordinated Universal Time，UTC）.不过用户看到 UTC 格式的时间会感到困惑，他们更希望看到当地时间，而且采用当地惯用的格式。&lt;/p&gt;&lt;p&gt;一个优雅的解决方案是，把时间单位发送给 Web 浏览器，转换成当地时间，然后渲染。&lt;/p&gt;&lt;h5 id=&#34;41跨站请求伪造保护&#34;&gt;4.1　跨站请求伪造保护&lt;/h5&gt;&lt;p&gt;默认情况下，Flask-WTF 能保护所有表单免受跨站请求伪造（Cross-Site Request Forgery，CSRF）的攻击。恶意网站把请求发送到被攻击者已登录的其他网站时就会引发 CSRF 攻击。&lt;/p&gt;&lt;p&gt;为了实现 CSRF 保护，Flask-WTF 需要程序设置一个密钥。Flask-WTF 使用这个密钥生成加密令牌，再用令牌验证请求中表单数据的真伪。设置密钥的方法如示例 4-1 所示。&lt;/p&gt;&lt;h5 id=&#34;42表单类&#34;&gt;4.2　表单类&lt;/h5&gt;&lt;p&gt;使用 Flask-WTF 时，每个 Web 表单都由一个继承自 Form 的类表示。这&lt;/p&gt;&lt;h5 id=&#34;43把表单渲染成html&#34;&gt;4.3　把表单渲染成HTML&lt;/h5&gt;&lt;p&gt;表单字段是可调用的，在模板中调用后会渲染成 HTML。假设视图函数把一个 NameForm 实例通过参数 form 传入模板，在模板中可以生成一个简单的表单，如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;form method=&amp;quot;POST&amp;quot;&amp;gt; {{ form.hidden_tag() }} {{ form.name.label }} {{ form.name() }} {{ form.submit() }}&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;44在视图函数中处理表单&#34;&gt;4.4　在视图函数中处理表单&lt;/h5&gt;&lt;p&gt;不仅要渲染表单，还要接收表单中的数据&lt;/p&gt;&lt;h5 id=&#34;45重定向和用户会话&#34;&gt;4.5　重定向和用户会话&lt;/h5&gt;&lt;p&gt;程序可以把数据存储在用户会话中，在请求之间“记住”数据。用户会话是一种私有存储，存在于每个连接到服务器的客户端中&lt;/p&gt;&lt;h5 id=&#34;46-flash消息&#34;&gt;4.6 Flash消息&lt;/h5&gt;&lt;p&gt;请求完成后，有时需要让用户知道状态发生了变化。这里可以使用确认消息、警告或者错误提醒。&lt;/p&gt;&lt;p&gt;仅调用 flash() 函数并不能把消息显示出来，程序使用的模板要渲染这些消息。最好在基模板中渲染Flash 消息，因为这样所有页面都能使用这些消息。Flask 把get_flashed_messages() 函数开放给模板，用来获取并渲染消息&lt;/p&gt;&lt;h5 id=&#34;51-sql数据库&#34;&gt;5.1 SQL数据库&lt;/h5&gt;&lt;p&gt;关系型数据库把数据存储在表中，表模拟程序中不同的实体。&lt;/p&gt;&lt;p&gt;表的列数是固定的，行数是可变的。列定义表所表示的实体的数据属性。&lt;/p&gt;&lt;p&gt;表中有个特殊的列，称为&lt;em&gt;主键&lt;/em&gt;，其值为表中各行的唯一标识符。表中还可以有称为&lt;em&gt;外键&lt;/em&gt;的列，引用同一个表或不同表中某行的主键。行之间的这种联系称为关系，这是关系型数据库模型的基础。&lt;/p&gt;&lt;h5 id=&#34;52-nosql数据库&#34;&gt;5.2 NoSQL数据库&lt;/h5&gt;&lt;p&gt;所有不遵循上节所述的关系模型的数据库统称为 NoSQL 数据库。&lt;/p&gt;&lt;p&gt;&lt;em&gt;使用 NoSQL 数据库当然也有好处。数据重复可以提升查询速度。列出用户及其角色的操作很简单，因为无需联结&lt;/em&gt;&lt;/p&gt;&lt;h5 id=&#34;53使用sql还是nosql&#34;&gt;5.3　使用SQL还是NoSQL&lt;/h5&gt;&lt;p&gt;SQL 数据库擅于用高效且紧凑的形式存储结构化数据。这种数据库需要花费大量精力保证数据的一致性。NoSQL 数据库放宽了对这种一致性的要求，从而获得性能上的优势。&lt;/p&gt;&lt;h5 id=&#34;54-python数据库框架&#34;&gt;5.4 Python数据库框架&lt;/h5&gt;&lt;p&gt;Flask 并不限制你使用何种类型的数据库包，因此可以根据自己的喜好选择使用 MySQL、Postgres、SQLite、Redis、MongoDB 或者 CouchDB。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;易用性&lt;/li&gt;&lt;li&gt;性能&lt;/li&gt;&lt;li&gt;可移植性&lt;/li&gt;&lt;/ol&gt;&lt;h5 id=&#34;55使用flask-sqlalchemy管理数据库&#34;&gt;5.5　使用Flask-SQLAlchemy管理数据库&lt;/h5&gt;&lt;p&gt;Flask-SQLAlchemy 是一个 Flask 扩展，简化了在 Flask 程序中使用 SQLAlchemy 的操作。&lt;/p&gt;&lt;h5 id=&#34;56定义模型&#34;&gt;5.6　定义模型&lt;/h5&gt;&lt;p&gt;&lt;em&gt;模型&lt;/em&gt;这个术语表示程序使用的持久化实体。&lt;/p&gt;&lt;h5 id=&#34;57关系&#34;&gt;5.7　关系&lt;/h5&gt;&lt;p&gt;关系型数据库使用关系把不同表中的行联系起来。&lt;/p&gt;&lt;h5 id=&#34;58数据库操作&#34;&gt;5.8　数据库操作&lt;/h5&gt;&lt;h6 id=&#34;581创建表&#34;&gt;5.8.1　创建表&lt;/h6&gt;&lt;p&gt;方法是使用 db.create_all()&lt;/p&gt;&lt;h6 id=&#34;582插入行&#34;&gt;5.8.2　插入行&lt;/h6&gt;&lt;p&gt;db.session.add(admin_role)&lt;/p&gt;&lt;h6 id=&#34;583修改行&#34;&gt;5.8.3　修改行&lt;/h6&gt;&lt;p&gt;db.session.add(admin_role)db.session.commit()&lt;/p&gt;&lt;h6 id=&#34;584删除行&#34;&gt;5.8.4　删除行&lt;/h6&gt;&lt;p&gt;db.session.delete(mod_role)db.session.commit()&lt;/p&gt;&lt;h6 id=&#34;585查询行&#34;&gt;5.8.5　查询行&lt;/h6&gt;&lt;p&gt;Flask-SQLAlchemy 为每个模型类都提供了 query 对象&lt;/p&gt;&lt;h5 id=&#34;59在视图函数中操作数据库&#34;&gt;5.9　在视图函数中操作数据库&lt;/h5&gt;&lt;h5 id=&#34;510集成python-shell&#34;&gt;5.10　集成Python shell&lt;/h5&gt;&lt;p&gt;每次启动 shell 会话都要导入数据库实例和模型，这真是份枯燥的工作。为了避免一直重复导入，我们可以做些配置，让 Flask-Script 的 shell 命令自动导入特定的对象。&lt;/p&gt;&lt;h5 id=&#34;511使用flask-migrate实现数据库迁移&#34;&gt;5.11　使用Flask-Migrate实现数据库迁移&lt;/h5&gt;&lt;h5 id=&#34;71项目结构&#34;&gt;7.1　项目结构&lt;/h5&gt;&lt;p&gt;多文件 Flask 程序的基本结构&lt;/p&gt;&lt;pre&gt;&lt;code&gt;|-flasky |-app/ |-templates/ |-static/ |-main/ |-__init__.py |-errors.py |-forms.py |-views.py |-__init__.py |-email.py |-models.py |-migrations/ |-tests/ |-__init__.py  |-test*.py |-venv/ |-requirements.txt |-config.py |-manage.py&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种结构有 4 个顶级文件夹：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Flask 程序一般都保存在名为 app 的包中；&lt;/li&gt;&lt;li&gt;和之前一样，migrations 文件夹包含数据库迁移脚本；&lt;/li&gt;&lt;li&gt;单元测试编写在 tests 包中；&lt;/li&gt;&lt;li&gt;和之前一样，venv 文件夹包含 Python 虚拟环境&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;同时还创建了一些新文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;requirements.txt 列出了所有依赖包，便于在其他电脑中重新生成相同的虚拟环境；&lt;/li&gt;&lt;li&gt;requirements.txt 列出了所有依赖包，便于在其他电脑中重新生成相同的虚拟环境；&lt;/li&gt;&lt;li&gt;manage.py 用于启动程序以及其他的程序任务。&lt;/li&gt;&lt;/ul&gt;&lt;h5 id=&#34;72配置选项&#34;&gt;7.2　配置选项&lt;/h5&gt;&lt;p&gt;程序经常需要设定多个配置。这方面最好的例子就是开发、测试和生产环境要使用不同的数据库，这样才不会彼此影响。&lt;/p&gt;&lt;h5 id=&#34;73程序包&#34;&gt;7.3　程序包&lt;/h5&gt;&lt;p&gt;程序包用来保存程序的所有代码、模板和静态文件。我们可以把这个包直接称为app&lt;/p&gt;&lt;h5 id=&#34;731使用程序工厂函数&#34;&gt;7.3.1　使用程序工厂函数&lt;/h5&gt;&lt;p&gt;在单个文件中开发程序很方便，但却有个很大的缺点，因为程序在全局作用域中创建，所以无法动态修改配置。运行脚本时，程序实例已经创建，再修改配置为时已晚。这一点对单元测试尤其重要，因为有时为了提高测试覆盖度，必须在不同的配置环境中运行程序。&lt;/p&gt;&lt;p&gt;这个问题的解决方法是延迟创建程序实例，把创建过程移到可显式调用的工厂函数中。这种方法不仅可以给脚本留出配置程序的时间，还能够创建多个程序实例，这些实例有时在测试中非常有用。&lt;/p&gt;&lt;h5 id=&#34;732在蓝本中实现程序功能&#34;&gt;7.3.2　在蓝本中实现程序功能&lt;/h5&gt;&lt;p&gt;蓝本和程序类似，也可以定义路由。不同的是，在蓝本中定义的路由处于休眠状态，直到蓝本注册到程序上后，路由才真正成为程序的一部分。使用位于全局作用域中的蓝本时，定义路由的方法几乎和单脚本程序一样。&lt;/p&gt;&lt;h5 id=&#34;74启动脚本&#34;&gt;7.4　启动脚本&lt;/h5&gt;&lt;p&gt;顶级文件夹中的 manage.py 文件用于启动程序。&lt;/p&gt;&lt;h5 id=&#34;75需求文件&#34;&gt;7.5　需求文件&lt;/h5&gt;&lt;p&gt;程序中必须包含一个 requirements.txt 文件，用于记录所有依赖包及其精确的版本号。如果要在另一台电脑上重新生成虚拟环境，这个文件的重要性就体现出来了，例如部署程序时使用的电脑。pip 可以使用如下命令自动生成这个文件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(venv) $ pip freeze &amp;gt;requirements.txt&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;76单元测试&#34;&gt;7.6　单元测试&lt;/h5&gt;&lt;h5 id=&#34;77创建数据库&#34;&gt;7.7　创建数据库&lt;/h5&gt;&lt;h5 id=&#34;81-flask的认证扩展&#34;&gt;8.1 Flask的认证扩展&lt;/h5&gt;&lt;h5 id=&#34;82密码安全性&#34;&gt;8.2　密码安全性&lt;/h5&gt;</description>
     </item>
   
     <item>
       <title>Okhttp 源码解析</title>
       <link>https://wooi.github.io/posts/okhttp_analyse/</link>
       <pubDate>Mon, 21 Nov 2016 14:09:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/okhttp_analyse/</guid>
       <description>&lt;h1 id=&#34;okhttp解析&#34;&gt;Okhttp解析&lt;/h1&gt;&lt;h3 id=&#34;总体思想&#34;&gt;总体思想&lt;/h3&gt;&lt;p&gt;分析源码，首先要熟悉用例，由上到下一层一层剥开源码，初步了解项目的框架，然后再细看代码的实现细节。现在试着分析 OKhttp 的源码，下面代码是来至 &lt;a href=&#34;https://square.github.io/okhttp/#examples&#34;&gt;OKhttp官网&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;GET A URL&lt;/p&gt;&lt;pre&gt;&lt;code&gt;OkHttpClient client = new OkHttpClient(); //(1)String run(String url) throws IOException {  Request request = new Request.Builder()      .url(url)      .build();                           //(2)  Response response = client.newCall(request).execute();  //(3)  return response.body().string();                        //(4)}&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;创建一个 OkHttpClient 对象。&lt;/li&gt;&lt;li&gt;创建一个 Request 对象，可以设置 URL 等网络配置。&lt;/li&gt;&lt;li&gt;调用 OkHttpClient 的 newCall() 方法，并把自定义配置的Request对象作为参数传进去。到处为止程序成功的将需要的请求放在了队列中，执行 execute() 方法开始向服务器发起请求，服务器返回的信息转化为 Response 对象。&lt;/li&gt;&lt;li&gt;返回 response 对象的 body 主体信息。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;一张来至&lt;a href=&#34;http://blog.piasy.com/&#34;&gt;piasy&lt;/a&gt;的流程图:&lt;img src=&#34;http://blog.piasy.com/img/201607/okhttp_full_process.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;细节分析&#34;&gt;细节分析&lt;/h3&gt;&lt;h4 id=&#34;创建-okhttpclient-对象&#34;&gt;创建 OkHttpClient 对象&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;OkHttpClient client = new OkHttpClient();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OkHttpClient.class 里面的两个构造函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public OkHttpClient() {    this(new Builder());  }  private OkHttpClient(Builder builder) {    this.dispatcher = builder.dispatcher;    this.proxy = builder.proxy;    this.protocols = builder.protocols;    .    .    .    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;    this.connectTimeout = builder.connectTimeout;    this.readTimeout = builder.readTimeout;    this.writeTimeout = builder.writeTimeout;  }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面可以看出，new OkHttpClient() 是调用 OkHttpClient.class 另外一个 private 的构造函数 OkHttpClient(Builder builder) ，其中 Builder 是 OkHttpClient 的一个内部类，Builder 是使用了&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/builder_pattern.htm&#34;&gt;构造者模式&lt;/a&gt;，里面包含了一些配置相关的字段如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    final Dispatcher dispatcher;  //分发器    final Proxy proxy; //代理    final List&amp;lt;Protocol&amp;gt; protocols; //协议    final List&amp;lt;ConnectionSpec&amp;gt; connectionSpecs; //传输层版本和连接协议    final List&amp;lt;Interceptor&amp;gt; interceptors; //拦截器    final List&amp;lt;Interceptor&amp;gt; networkInterceptors; //网络拦截器    .    .    .    final int readTimeout; //read 超时    final int writeTimeout; //write 超时&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;创建-request-对象&#34;&gt;创建 Request 对象&lt;/h4&gt;&lt;p&gt;创建完 OkHttpClient 对象后，就需要我们创建一个Request，Request 作用就是承载用户的请求，最简单的也是必须的做法是设置  Request 的 URL。同样和创建 OkHttpClient 对象一样，Request 也是使用 构造者模式，其中包含了 URL, header, body等字段，简单看看源码中的 Request 的构造函数：&lt;/p&gt;&lt;pre&gt;&lt;code&gt; private Request(Builder builder) {    this.url = builder.url;    this.method = builder.method;    this.headers = builder.headers.build();    this.body = builder.body;    this.tag = builder.tag != null ? builder.tag : this;  }&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;真正开始工作啦&#34;&gt;真正开始工作啦&lt;/h4&gt;&lt;h5 id=&#34;同步请求&#34;&gt;同步请求&lt;/h5&gt;&lt;p&gt;最上面的官方示例代码是一个同步的网络请求，接着我们一步一步拆解代码。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//官方示例代码Response response = client.newCall(request).execute(); &lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;//OkHttpClient.classpublic Call newCall(Request request) {    return new RealCall(this, request);  }&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;//Recall.class  protected RealCall(OkHttpClient client, Request originalRequest) {    this.client = client;    this.originalRequest = originalRequest;    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client);  }      @Override protected void execute() {      boolean signalledCallback = false;      try {        Response response = getResponseWithInterceptorChain();        if (retryAndFollowUpInterceptor.isCanceled()) {          signalledCallback = true;          responseCallback.onFailure(RealCall.this, new IOException(&amp;quot;Canceled&amp;quot;));        } else {          signalledCallback = true;          responseCallback.onResponse(RealCall.this, response);        }      } catch (IOException e) {        if (signalledCallback) {          // Do not signal the callback twice!          Platform.get().log(INFO, &amp;quot;Callback failure for &amp;quot; + toLoggableString(), e);        } else {          responseCallback.onFailure(RealCall.this, e);        }      } finally {        client.dispatcher().finished(this);      }    }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 OkhttpClient 代码里面看到，newCall() 函数返回一个 Call 对象，其实 Call 是一个接口，而我们的没一次请求都是转载在一个 Call 对象中。其中看到返回的是一个 RealCall 对象，由这里看到 RealCall 是 Call 的一个实现类。&lt;/p&gt;&lt;p&gt;Ok，接着看看 RealCall 对象的 execute() 方法，可以看到这样一行最重要的代码 Response response = getResponseWithInterceptorChain() ，通过这一个方法可得到从服务器返回的一个 Response 对象。从这个函数的名字可以推测，这是一个接一个的链式调用，接下来也可以从源码发现，这个地方使用了&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/chain_of_responsibility_pattern.htm&#34;&gt;责任链模式&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//RealCall.callprivate Response getResponseWithInterceptorChain() throws IOException {    // Build a full stack of interceptors.    List&amp;lt;Interceptor&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;();    interceptors.addAll(client.interceptors());    interceptors.add(retryAndFollowUpInterceptor);    interceptors.add(new BridgeInterceptor(client.cookieJar()));    interceptors.add(new CacheInterceptor(client.internalCache()));    interceptors.add(new ConnectInterceptor(client));    if (!retryAndFollowUpInterceptor.isForWebSocket()) {      interceptors.addAll(client.networkInterceptors());    }    interceptors.add(new CallServerInterceptor(        retryAndFollowUpInterceptor.isForWebSocket()));    Interceptor.Chain chain = new RealInterceptorChain(        interceptors, null, null, null, 0, originalRequest);    return chain.proceed(originalRequest);  }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上的代码总的功能就是往一个 list 里面一个一个的添加 interceptor ，interceptor 是一个抽象的接口，而代码里添加的各种各样的拦截器都是对 interceptor 接口不同的实现。例如，首先添加用户自己配置的interceptor，然后添加 retryAndFollowUpInterceptor 主要负责重定向和失败重连，接着添加 BridgeInterceptor 主要负责转化用户配置的url，header等配置生成一个服务器能接受的文本格式。列表中 CacheInterceptor 我们大概能猜出它的作用，这是一个缓存拦截器，根据 url 读取缓存中的数据，如果有结果就在这里砍断链式调用，成功返回结果。 ConnectInterceptor 则是开始向服务器发起连接。CallServerInterceptor 是正式与服务器发生关系，也是从这个拦截器中返回最终的 Response 结果。&lt;/p&gt;&lt;p&gt;当然，要发生上述的所有动作必须有一个起点，chain.proceed(originalRequest) 就是整个链路的入口，就在这里开始一个环节扣着一个环节执行下去。放回最终的结果，这不，一次完整的同步网络请求就完成了。&lt;/p&gt;&lt;h5 id=&#34;异步请求&#34;&gt;异步请求&lt;/h5&gt;&lt;p&gt;上面是一个同步请求的解析，现在来谈谈异步请求，它跟同步请求有异曲同工之妙，大部分的流程实现还是沿用同一份代码，最大的不同是异步请求加入了 dispatcher ，见面知其意，就是由这个类来负责分发用户的请求。按照上面的思路，首先看看一个异步的示例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//异步示例OkHttpClient client=new OkHttpClient();Request request = new Request.Builder()                        .url(url)                        .build();client.newCall(request)        .enqueue(new Callback() {            @Override            public void onResponse(Call call, Response response) throws IOException {            }            @Override            public void onFailure(Call call, IOException e) {            }        });&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Request 和 OkHttpClient 创建和同步请求一致，重点在与 RealCall() 接口里面的 enqueue(CallBack callback) 方法。传入的当然是一个 CallBack 接口对象用户需要服务器返回的消息通过这个对象传递回来。复写的 onResponse() 成功获取服务器端返回的结果，onFailure() 返回错误失败的信息，下面接着看 enqueued() 调用栈。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//RealCall.class  @Override   public void enqueue(Callback responseCallback) {    synchronized (this) {      if (executed) throw new IllegalStateException(&amp;quot;Already Executed&amp;quot;);      executed = true;    }    client.dispatcher().enqueue(new AsyncCall(responseCallback));  }    //RealCall 内部类继承NamedRunnable（代码向下滑）  final class AsyncCall extends NamedRunnable {    private final Callback responseCallback;    private AsyncCall(Callback responseCallback) {      super(&amp;quot;OkHttp %s&amp;quot;, redactedUrl().toString());      this.responseCallback = responseCallback;    }        @Override protected void execute() {      boolean signalledCallback = false;      try {        Response response = getResponseWithInterceptorChain();        if (retryAndFollowUpInterceptor.isCanceled()) {          signalledCallback = true;          responseCallback.onFailure(RealCall.this, new IOException(&amp;quot;Canceled&amp;quot;));        } else {          signalledCallback = true;          responseCallback.onResponse(RealCall.this, response);        }      } catch (IOException e) {        if (signalledCallback) {          // Do not signal the callback twice!          Platform.get().log(INFO, &amp;quot;Callback failure for &amp;quot; + toLoggableString(), e);        } else {          responseCallback.onFailure(RealCall.this, e);        }      } finally {        client.dispatcher().finished(this);      }    }  }  &lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;//Dispatcher.class  private final Deque&amp;lt;AsyncCall&amp;gt; readyAsyncCalls = new ArrayDeque&amp;lt;&amp;gt;();  private final Deque&amp;lt;AsyncCall&amp;gt; runningAsyncCalls = new ArrayDeque&amp;lt;&amp;gt;();  private final Deque&amp;lt;RealCall&amp;gt; runningSyncCalls = new ArrayDeque&amp;lt;&amp;gt;();   synchronized void enqueue(AsyncCall call) {    if (runningAsyncCalls.size() &amp;lt; maxRequests &amp;amp;&amp;amp; runningCallsForHost(call) &amp;lt; maxRequestsPerHost) {      runningAsyncCalls.add(call);      executorService().execute(call);    } else {      readyAsyncCalls.add(call);    }  }&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;//NamedRunnable.classpublic abstract class NamedRunnable implements Runnable {  protected final String name;  public NamedRunnable(String format, Object... args) {    this.name = Util.format(format, args);  }  @Override public final void run() {    String oldName = Thread.currentThread().getName();    Thread.currentThread().setName(name);    try {      execute();    } finally {      Thread.currentThread().setName(oldName);    }  }  protected abstract void execute();}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RealCall 类 enqueue(Callback responseCallback) 中可以看到 dispatcher() 方法 ，dispatcher 也有一个 enqueue(AsyncCall call) 方法， 在这个 enqueue 方法里有一个列表并且执行 AsynCall ，如何执行 AsynCall 呢? AsynCall 是 RealCall 的内部类，集成 NamedRunnable，NamedRunnable 继承 Runanble。最终的与服务器发生交互的动作就在 AsynCall 的 execute() 方法内，这里就看到了熟悉的一行代码 ：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Response response = getResponseWithInterceptorChain();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行的流程就和同步的请求一模一样，不同点是再取得的服务器最终结果 Callback 接口放回给用户。&lt;/p&gt;&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;&lt;p&gt;更好读懂 OKHttp 的源码关键是要了解常用的设计模式，用构造模式创建出 OkHttpClient 和 Request 对象，使用责任链模式完成一个链式的调用。个人认为这就是 OkHttp 最基本的框架。代码的还有许多设计精良的部分，还未还好细读，目前还不把每一部分做到庖丁解牛的境界，有时间再一另帮 Blog 做另外的分析。&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>Java 的拷贝</title>
       <link>https://wooi.github.io/posts/javaclone/</link>
       <pubDate>Mon, 21 Nov 2016 14:05:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/javaclone/</guid>
       <description>&lt;h1 id=&#34;对象的拷贝&#34;&gt;对象的拷贝&lt;/h1&gt;&lt;h2 id=&#34;深度拷贝一个对象&#34;&gt;深度拷贝一个对象&lt;/h2&gt;&lt;p&gt;java.lang.Object 根类已经定义了 clone() 方法。子类只需要事项 java.lang.Cloneable 接口，就可以返回一个拷贝的对象。实现接口的同时要实现 clone() 方法里面的实现。这是拷贝方式就是浅拷贝(shallow copy of object)，这代表着原有对象的值复制一份存储在一个新的对象里面。&lt;/p&gt;&lt;p&gt;浅拷贝并不是完全复制原对象的所有内容，除了基本类型(int,float&amp;hellip;)，引用类型只是复制一份引用对象的引用，那么原有的对象和拷贝的对象就指共同指向同一个引用对象。这样使用浅拷贝就会导致一些不可预测的错误。看看项目 Exampl1的例子。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class Example1 {    public static void main(String[] args) {        // Make a Vector        Vector original = new Vector();        // Make a StringBuffer and add it to the Vector        StringBuffer text = new StringBuffer(&amp;quot;The quick brown fox&amp;quot;);        original.addElement(text);        // Clone the vector and print out the contents        Vector clone = (Vector) original.clone();        System.out.println(&amp;quot;A. After cloning&amp;quot;);        printVectorContents(original, &amp;quot;original&amp;quot;);        printVectorContents(clone, &amp;quot;clone&amp;quot;);        System.out.println(            &amp;quot;--------------------------------------------------------&amp;quot;);        System.out.println();        // Add another object (an Integer) to the clone and         // print out the contents        clone.addElement(new Integer(5));        System.out.println(&amp;quot;B. After adding an Integer to the clone&amp;quot;);        printVectorContents(original, &amp;quot;original&amp;quot;);        printVectorContents(clone, &amp;quot;clone&amp;quot;);        System.out.println(            &amp;quot;--------------------------------------------------------&amp;quot;);        System.out.println();        // Change the StringBuffer contents        text.append(&amp;quot; jumps over the lazy dog.&amp;quot;);        System.out.println(&amp;quot;C. After modifying one of original&#39;s elements&amp;quot;);        printVectorContents(original, &amp;quot;original&amp;quot;);        printVectorContents(clone, &amp;quot;clone&amp;quot;);        System.out.println(            &amp;quot;--------------------------------------------------------&amp;quot;);        System.out.println();    }    public static void printVectorContents(Vector v, String name) {        System.out.println(&amp;quot;  Contents of \&amp;quot;&amp;quot; + name + &amp;quot;\&amp;quot;:&amp;quot;);        // For each element in the vector, print out the index, the        // class of the element, and the element itself        for (int i = 0; i &amp;lt; v.size(); i++) {            Object element = v.elementAt(i);            System.out.println(&amp;quot;   &amp;quot; + i + &amp;quot; (&amp;quot; +                 element.getClass().getName() + &amp;quot;): &amp;quot; +                 element);        }        System.out.println();    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Exampl1 运行输出的结果：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;A. After cloning  Contents of &amp;quot;original&amp;quot;:   0 (java.lang.StringBuffer): The quick brown fox  Contents of &amp;quot;clone&amp;quot;:   0 (java.lang.StringBuffer): The quick brown fox--------------------------------------------------------B. After adding an Integer to the clone  Contents of &amp;quot;original&amp;quot;:   0 (java.lang.StringBuffer): The quick brown fox  Contents of &amp;quot;clone&amp;quot;:   0 (java.lang.StringBuffer): The quick brown fox   1 (java.lang.Integer): 5--------------------------------------------------------C. After modifying one of original&#39;s elements  Contents of &amp;quot;original&amp;quot;:   0 (java.lang.StringBuffer): The quick brown fox jumps over the lazy dog.  Contents of &amp;quot;clone&amp;quot;:   0 (java.lang.StringBuffer): The quick brown fox jumps over the lazy dog.   1 (java.lang.Integer): 5--------------------------------------------------------&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果打印出3个区域块，在第一个区域块中成功的创建了一个对象和复制拷贝了一个一模一样的对象。从第二个区域块可以看出两个对象是相互对立的，当往复制拷贝的对象添加一个 Integer 数值，打印的结果显示原有的对象不受影响，复制拷贝的对象打印添加的数值。第三个区域块修改了 StringBuffer 的值，打印显示出两个对象里面的内容同时被修改了，这恰恰验证了上面的说法，应用类型的值时用 clone 时无法被完全复制过去的。&lt;/p&gt;&lt;p&gt;所以使用 clone 这种方法复制内容可能会造成不可预测的错误。&lt;/p&gt;&lt;p&gt;为了解决浅拷贝带来的问题，另外的解决方案是使用&lt;em&gt;深度拷贝(deep copy of object)&lt;/em&gt; 。深度拷贝使得原有对象和新对象完全独立，对象里面的所有属性都完成被复制过去。Java Api 提供的 clone 方法无法一步到位的深度拷贝，只能为对象里面的所有的熟悉均实现 Cloneable 接口，为所有的属性变量 clone 一遍。就如同上的例子，需要重写 clone 方法拷贝一个新的字符串，再把新的字符串对象复制给 Vector克隆出来的对象。不过这种做法有几点缺点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;要拷贝一个对象，必须修改这个类里面所有元素的 clone 方法。假如你使用第三库的代码，而且没有源码这就无法使用这个方法，还有如果使用 final 修饰变量这也是没使用这个拷贝方法&lt;/li&gt;&lt;li&gt;要有权限访问父类属性变量，如果某个变量是私有属性就没有权限修改它&lt;/li&gt;&lt;li&gt;必须要确定属性变量的类型，尤其不能运行中才能确定的类型&lt;/li&gt;&lt;li&gt;操作繁琐容易出错&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;另外一种通用的办法就是使用 Java Object Serialization (JOS) ，使用序列化，使用把 ObjectOutputStream       对象写入出入到一个数组中，再使用 ObjectInputStream 复制到另一个对象，从而得到两个完全独立的对象。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import java.io.IOException;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;/** * Utility for making deep copies (vs. clone()&#39;s shallow copies) of  * objects. Objects are first serialized and then deserialized. Error * checking is fairly minimal in this implementation. If an object is * encountered that cannot be serialized (or that references an object * that cannot be serialized) an error is printed to System.err and * null is returned. Depending on your specific application, it might * make more sense to have copy(...) re-throw the exception. * * A later version of this class includes some minor optimizations. */public class UnoptimizedDeepCopy {    /**     * Returns a copy of the object, or null if the object cannot     * be serialized.     */    public static Object copy(Object orig) {        Object obj = null;        try {            // Write the object out to a byte array            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream out = new ObjectOutputStream(bos);            out.writeObject(orig);            out.flush();            out.close();            // Make an input stream from the byte array and read            // a copy of the object back in.            ObjectInputStream in = new ObjectInputStream(                new ByteArrayInputStream(bos.toByteArray()));            obj = in.readObject();        }        catch(IOException e) {            e.printStackTrace();        }-快速深度拷贝一个对象        catch(ClassNotFoundException cnfe) {            cnfe.printStackTrace();        }        return obj;    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方法也是有缺点的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;必须序列化，都要实现 java.io.Serializable 接口&lt;/li&gt;&lt;li&gt;序列化影响程序运输速度。&lt;/li&gt;&lt;li&gt;可以适应不同的对象大小，创建适合大小的数组，可以在多线程任务中安全使用。符合上面种种特点，可想而知速度是有多慢。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;出于以上的种种缺点，可以对 ByteArrayOutputStream 和 ByteArrayInputStream 做出3点优化：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ByteArrayOutputStream 默认初始化 32 byte的数组，遇到大的对象就增大为目前两倍大的数组，这意味着要摒弃到初始化的小数组，优化这个问题的方法也简单，初始化一个大的数组。&lt;/li&gt;&lt;li&gt;ByteArrayOutputStream 修改的内容都是 synchronized 修饰的，这是个安全的做法，但是在确定的单一线程里许可以抛弃 synchronized 这样做也是安全的。&lt;/li&gt;&lt;li&gt;toByteArray() 方法会创建和复制一个字节流数组。检索数据数组然后继续写入流中，原有的数据就不会被改变。尽管如此，这循环复制一个数组会造成多余的垃圾回收工作。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;#深度拷贝速度优化&lt;/p&gt;&lt;p&gt;FastByteArrayOutputStream.class&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.ByteArrayInputStream;/** * ByteArrayOutputStream implementation that doesn&#39;t synchronize methods * and doesn&#39;t copy the data on toByteArray(). */public class FastByteArrayOutputStream extends OutputStream {    /**     * Buffer and size     */    protected byte[] buf = null;    protected int size = 0;    /**     * Constructs a stream with buffer capacity size 5K      */    public FastByteArrayOutputStream() {        this(5 * 1024);    }    /**     * Constructs a stream with the given initial size     */    public FastByteArrayOutputStream(int initSize) {        this.size = 0;        this.buf = new byte[initSize];    }    /**     * Ensures that we have a large enough buffer for the given size.     */    private void verifyBufferSize(int sz) {        if (sz &amp;gt; buf.length) {            byte[] old = buf;            buf = new byte[Math.max(sz, 2 * buf.length )];            System.arraycopy(old, 0, buf, 0, old.length);            old = null;        }    }    public int getSize() {        return size;    }    /**     * Returns the byte array containing the written data. Note that this     * array will almost always be larger than the amount of data actually     * written.     */    public byte[] getByteArray() {        return buf;    }    public final void write(byte b[]) {        verifyBufferSize(size + b.length);        System.arraycopy(b, 0, buf, size, b.length);        size += b.length;    }    public final void write(byte b[], int off, int len) {        verifyBufferSize(size + len);        System.arraycopy(b, off, buf, size, len);        size += len;    }    public final void write(int b) {        verifyBufferSize(size + 1);        buf[size++] = (byte) b;    }    public void reset() {        size = 0;    }    /**     * Returns a ByteArrayInputStream for reading back the written data     */    public InputStream getInputStream() {        return new FastByteArrayInputStream(buf, size);    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ByteArrayInputStream.class&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import java.io.InputStream;import java.io.IOException;/** * ByteArrayInputStream implementation that does not synchronize methods. */public class FastByteArrayInputStream extends InputStream {    /**     * Our byte buffer     */    protected byte[] buf = null;    /**     * Number of bytes that we can read from the buffer     */    protected int count = 0;    /**     * Number of bytes that have been read from the buffer     */    protected int pos = 0;    public FastByteArrayInputStream(byte[] buf, int count) {        this.buf = buf;        this.count = count;    }    public final int available() {        return count - pos;    }    public final int read() {        return (pos &amp;lt; count) ? (buf[pos++] &amp;amp; 0xff) : -1;    }    public final int read(byte[] b, int off, int len) {        if (pos &amp;gt;= count)            return -1;        if ((pos + len) &amp;gt; count)            len = (count - pos);        System.arraycopy(buf, pos, b, off, len);        pos += len;        return len;    }    public final long skip(long n) {        if ((pos + n) &amp;gt; count)            n = count - pos;        if (n &amp;lt; 0)            return 0;        pos += n;        return n;    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ByteArrayInputStream 和 ByteArrayOutputStream 的使用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import java.io.IOException;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;/** * Utility for making deep copies (vs. clone()&#39;s shallow copies) of  * objects. Objects are first serialized and then deserialized. Error * checking is fairly minimal in this implementation. If an object is * encountered that cannot be serialized (or that references an object * that cannot be serialized) an error is printed to System.err and * null is returned. Depending on your specific application, it might * make more sense to have copy(...) re-throw the exception. */public class DeepCopy {    /**     * Returns a copy of the object, or null if the object cannot     * be serialized.     */    public static Object copy(Object orig) {        Object obj = null;        try {            // Write the object out to a byte array            FastByteArrayOutputStream fbos =                     new FastByteArrayOutputStream();            ObjectOutputStream out = new ObjectOutputStream(fbos);            out.writeObject(orig);            out.flush();            out.close();            // Retrieve an input stream from the byte array and read            // a copy of the object back in.             ObjectInputStream in =                 new ObjectInputStream(fbos.getInputStream());            obj = in.readObject();        }        catch(IOException e) {            e.printStackTrace();        }        catch(ClassNotFoundException cnfe) {            cnfe.printStackTrace();        }        return obj;    }}&lt;/code&gt;&lt;/pre&gt;</description>
     </item>
   
     <item>
       <title>List简介</title>
       <link>https://wooi.github.io/posts/java-list/</link>
       <pubDate>Mon, 21 Nov 2016 14:05:00 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/java-list/</guid>
       <description>&lt;h1 id=&#34;list简介&#34;&gt;List简介&lt;/h1&gt;&lt;h3 id=&#34;list-四种实现类&#34;&gt;List 四种实现类&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;ArrayList&lt;/li&gt;&lt;li&gt;LinkeList&lt;/li&gt;&lt;li&gt;Vector&lt;/li&gt;&lt;li&gt;Stack&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&#34;四种list的数据结构&#34;&gt;四种List的数据结构&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;ArrayList动态数组，初始化分配一定长度的数组&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;LinkeList双向链表&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Vector与 ArrayList 一样使用动态数组作为存储结构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;StackStack 继承 Vector ，不同的点是 Stack 是栈而不是队列，实现先进后出&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&#34;四种list的不同使用场景的效率&#34;&gt;四种List的不同使用场景的效率&lt;/h3&gt;&lt;p&gt;四种 List 实现其实根据数据结构可以分为两类，ArrayList，Vector，Stack 都是动态数组划分为一类，后面一ArrayList作为代表作比较分析。另一类就用是双向链表(包含当前的值和前节点和后节点e)实现 LinkedList。&lt;/p&gt;&lt;p&gt;根据链表和数组的比较，链表在插入，删除操作效率更高，但是随机读取效率相比数组就比较低。相反的，插入或删除一个数据就需要更长的时间，因为被修改位置后续的坐标全都要后移一位，所以耗时较长。&lt;/p&gt;&lt;p&gt;源码中可以看出，LinkedList 寻找的 index 大于List 长度的一半时，则会从后面开始读取数据而数组的 List 直接根据下标返回所需的元素&lt;/p&gt;&lt;h3 id=&#34;arraylist-与-vector-关于现场安全的比较&#34;&gt;ArrayList 与 Vector 关于现场安全的比较&lt;/h3&gt;&lt;p&gt;ArrayList 非现成安全，Vector 线程安全，所以在对单线程中使用 ArrayList 的效率要高于Vector&lt;/p&gt;&lt;h3 id=&#34;arraylist-的遍历速度比较&#34;&gt;ArrayList 的遍历速度比较&lt;/h3&gt;&lt;p&gt;随机范围的效率最高随机访问 &amp;gt; for循环 &amp;gt; 遍历器&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>算法学习笔记 - Alogrithm Fourth Edition</title>
       <link>https://wooi.github.io/posts/alogrithm/</link>
       <pubDate>Mon, 21 Nov 2016 14:04:24 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/alogrithm/</guid>
       <description>&lt;h1 id=&#34;算法学习笔记---alogrithm-fourth-edition&#34;&gt;算法学习笔记 - Alogrithm Fourth Edition&lt;/h1&gt;&lt;h2 id=&#34;排序算法&#34;&gt;排序算法&lt;/h2&gt;&lt;h4 id=&#34;选择排序selection&#34;&gt;选择排序(Selection)&lt;/h4&gt;&lt;p&gt;如果有N个数组，从第一个元素开始往后选择，与后面的每一个元素做对比，挑出最小的元素，如果后面元素中有一个最小的值，则把这个值放到第一位。然后从第二位数开始，继续往后面的元素做对比，挑出最小元素，如果后面元素中有一个最小的值，则把这个值放到第二位。以此重复操作到第N位，排序就完成了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class Selection {Selection() {}public static void main(String[] args) {int[] a = new int[] { 1, 2, 5, 7, 9, 12, 93, 5, 4, 6, 88 };show(a);Selection.sort(a);show(a);}public static void sort(int[] a) {for (int i = 0; i &amp;lt; a.length; i++) {int mini = i;for (int j = i + 1; j &amp;lt; a.length; j++) {if (less(a[j], a[mini])) {mini = j;}}exch(a, i, mini);}}private static boolean less(int v, int w) {return v &amp;lt; w;}private static void exch(int[] a, int i, int j) {Object swap = a[i];a[i] = a[j];a[j] = (int) swap;}private static void show(int[] a) {for (int i = 0; i &amp;lt; a.length; i++) {System.out.print(a[i] + &amp;quot; &amp;quot;);}System.out.println();}}&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;插入排序&#34;&gt;插入排序&lt;/h4&gt;&lt;p&gt;假设有N个元素的数组，从第二元素开始，与左边的第一元素比较，如果第二个比第一个元素小则插入第一个前面。接着从第三个开始与左边元素与第二个比较，如果第三个小于第二个，则插入到第二个前面，接着比较第一个。以此类推。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;package com.srs.test;public class Insert {Insert() {}public static void main(String[] args) {int[] a = new int[] { 1, 2, 5, 7, 9, 12, 93, 5, 4, 6, 88 };show(a);Selection.sort(a);show(a);}private void sort(int[] a) {for (int i = 1; i &amp;lt; a.length; i++) {for(int j = i;j&amp;gt;0&amp;amp;&amp;amp;less(a,j,j-1);j--){exch(a,j,j-1);}}}private boolean less(int[] a,int i,int j){return a[i]&amp;lt;a[j];}private static void exch(int[] a, int i, int j) {Object swap = a[i];a[i] = a[j];a[j] = (int) swap;}private static void show(int[] a) {for (int i = 0; i &amp;lt; a.length; i++) {System.out.print(a[i] + &amp;quot; &amp;quot;);}System.out.println();}}&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h4&gt;&lt;p&gt;插入排序在极端情况下有可能最右端的数值要经过其他全部数值的比较才到达第一位。所以当数组长度很大时，排序的效率就非常低了，后来便有了希尔排序，希尔排序是插入排序的优化，它的基础原理思想就是，将数组分成几个小队列，让数组元素跨数组排列。当分组排列完成后，缩小组别的长度，重复上面的排序，直至最后做普通的插入排序即完成了希尔排序；&lt;/p&gt;&lt;ul&gt;&lt;li&gt;例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;13 14 94 33 82&lt;br&gt;25 59 94 65 23&lt;br&gt;45 27 73 25 39&lt;br&gt;10&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;然后我们对每列进行排序：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;10 14 73 25 23&lt;br&gt;13 27 94 33 39&lt;br&gt;25 59 94 65 82&lt;br&gt;45&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;10 14 73&lt;br&gt;25 23 13&lt;br&gt;27 94 33&lt;br&gt;39 25 59&lt;br&gt;94 65 82&lt;br&gt;45&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;排序之后变为：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;10 14 13&lt;br&gt;25 23 33&lt;br&gt;27 25 59&lt;br&gt;39 65 73&lt;br&gt;45 94 82&lt;br&gt;94&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;最后以1步长进行排序（此时就是简单的插入排序了）。&lt;/p&gt;&lt;p&gt;代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class Shell extends BaseClass {public static void main(String[] args) {startTest(new Shell());}@Overridepublic void sort(int[] a) {int n = a.length;int h = 1;while (h &amp;lt; n / 3)h = 3 * h + 1;while (h &amp;gt;= 1) {for (int i = h; i &amp;lt; n; i++) {for (int j = i - h; j &amp;gt;= 0 &amp;amp;&amp;amp; less(a, j + h, j); j -= h) {exch(a, j + h, j);}}h /= 3;}}}&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;归并排序&#34;&gt;归并排序&lt;/h4&gt;&lt;p&gt;分治是归并排序的基本思想，将一数组通过不断的分化，直至最小，元素数量为2的小数组，小数组排序后再和其他小数组合并合并的时候也做排序，合并完成后再与另外一组同样有小数组再继续合并，指导最终排序完成&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class Merge extends BaseClass {public static void main(String[] args) {startTest(new Merge());}@Overridepublic void sort(int[] a) {sort(a,0,a.length-1);}public void sort(int[] a, int lo, int hi) {if (hi &amp;lt;= lo)return;int mid = lo+(hi - lo) / 2;sort(a, lo, mid);sort(a, mid + 1, hi);merge(a, lo, mid, hi);}public void merge(int[] a, int lo, int mid, int hi) {int i = lo, j = mid + 1;int[] arr = new int[a.length];for (int k = lo; k &amp;lt;= hi; k++) {arr[k] = a[k];}for (int k = lo; k &amp;lt;= hi; k++) {if (i &amp;gt; mid) {a[k] = arr[j++];} else if (j &amp;gt; hi) {a[k] = arr[i++];} else if (less(arr[j], arr[i])) {a[k] = arr[j++];} else {a[k] = arr[i++];}}}}&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;快速排序&#34;&gt;快速排序&lt;/h4&gt;&lt;p&gt;快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。选取一个基准值，程序同时从左端和右端向中间靠拢，首先左端和右端同基准值做比较，左端小于基准值时光标继续移动，直至左端大于基准值，右端的大于基准值时光标继续移动，直至右端小于基准值，这时候交换左端右端位置。接着继续移动左右端光标重复以上操作。当两端相遇时完成左右端大小归类。然后继续分裂左右端归类后的数组，数组不能再继续分裂排序就完成了&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class Quick extends BaseClass {public static void main(String[] args) {startTest(new Quick());}@Overridepublic void sort(int[] a) {sort(a,0,a.length-1);}public void sort(int[] a, int lo, int hi) {if (lo &amp;gt;= hi) {return;}int j = partition(a, lo, hi);sort(a, lo, j-1);sort(a, j + 1, hi);}private int partition(int[] a, int lo, int hi) {int i = lo, j = hi + 1;int v = a[lo];while (true) {while (less(a[++i], v)) {if (i == hi) {break;}}while (less(v, a[--j])) {if (j == lo) {break;}}if (i &amp;gt;= j) {break;}exch(a, i, j);}exch(a, lo, j);return j;}}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;优先队列&#34;&gt;优先队列&lt;/h2&gt;&lt;h3 id=&#34;堆的定义&#34;&gt;堆的定义&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;当一棵二叉树的每一个结点都大于等于它的两个子节点是，它被称为有序堆&lt;/p&gt;&lt;/blockquote&gt;</description>
     </item>
   
     <item>
       <title>泛型</title>
       <link>https://wooi.github.io/posts/generics/</link>
       <pubDate>Mon, 21 Nov 2016 11:55:54 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/generics/</guid>
       <description>&lt;h1 id=&#34;泛型&#34;&gt;泛型&lt;/h1&gt;&lt;p&gt;泛型程序设计是程序设计语言的一种风格或范式。在强类型程序设计语言中必须要指定变量的类型，否则就过不了编译器那一关，而泛型的用途就是让程序员可以写出程序运行过程中确定变量的类型，简单来说泛型就是用一个特殊的符号代表变量的类型。&lt;/p&gt;&lt;h1 id=&#34;泛型的定义及目的&#34;&gt;泛型的定义及目的&lt;/h1&gt;&lt;p&gt;泛型的定义主要有以下两种：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。（这是当今较常见的定义）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（现在人们大多把这称作模板）不论使用那个定义，泛型的参数在真正使用泛型时都必须作出指明。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;一些强类型程序语言支持泛型，其主要目的是加强类型安全及减少类转换的次数，但一些支持泛型的程序语言只能达到部分目的。&lt;/p&gt;&lt;h1 id=&#34;伪代码例子&#34;&gt;伪代码例子&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;類例泛類&amp;lt;T&amp;gt; {　　值 : T　　設置值(新值 : T) {　　　　值 := 新值　　}　　獲取值() : T {　　　　返回　值　　}}例方法1() {　　例物件 : 例泛類&amp;lt;整數型&amp;gt;　　例物件 := 新　例泛類&amp;lt;整數型&amp;gt;()　　例物件.設置值(5)　　输出整数(例对象.获取值())}例方法2() {　　例物件 : 例泛-{}-類&amp;lt;浮點數型&amp;gt;　　例物件 := 新　例泛類&amp;lt;浮點數型&amp;gt;()　　例物件.設置值(5.5)　　输出浮点数(例对象.获取值())}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;this article from &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B&#34;&gt;wikipedia&lt;/a&gt;&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>BindSevice的几种使用方法</title>
       <link>https://wooi.github.io/posts/bindsevice/</link>
       <pubDate>Tue, 11 Oct 2016 22:00:07 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/bindsevice/</guid>
       <description>&lt;h1 id=&#34;绑定服务&#34;&gt;绑定服务&lt;/h1&gt;&lt;p&gt;绑定服务是客户端-服务器接口中的服务器。绑定服务可让组件（例如 Activity）绑定到服务、发送请求、接收响应，甚至执行进程间通信 (IPC)。 绑定服务通常只在为其他应用组件服务时处于活动状态，不会无限期在后台运行。&lt;/p&gt;&lt;h2 id=&#34;sevice&#34;&gt;Sevice&lt;/h2&gt;&lt;p&gt;以下这个服务可让客户端通过 Binder 实现访问服务中的方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class LocalService extends Service {    IBinder mBinder = new LocalBinder();    private final Random mGenerator = new Random();    public class LocalBinder extends Binder {        LocalService getService() {            return LocalService.this;        }    }    @Nullable    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }    public int getRandomNumber() {        return mGenerator.nextInt(100);    }}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;client&#34;&gt;Client&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity {    LocalService mService;    Button button;    Boolean mBound;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        button = (Button) findViewById(R.id.button);        button.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                if (mBound) {                    int num = mService.getRandomNumber();                    Toast.makeText(getApplicationContext(), String.valueOf(num), Toast.LENGTH_LONG).show();                }            }        });    }    @Override    protected void onStart() {        super.onStart();        Intent intent = new Intent(this, LocalService.class);        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);    }    @Override    protected void onStop() {        super.onStop();        unbindService(mConnection);    }    private ServiceConnection mConnection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {            LocalService.LocalBinder binder = (LocalService.LocalBinder) iBinder;            mService = binder.getService();            mBound = true;        }        @Override        public void onServiceDisconnected(ComponentName componentName) {            mBound = false;        }    };}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;messagersevice&#34;&gt;MessagerSevice&lt;/h2&gt;&lt;p&gt;以下是一个使用 Messenger 接口的简单服务示例：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class MessengerService extends Service {    static final int MSG_SAY_HELLO = 1;    Messenger mMessenger = new Messenger(new IncomingHandler());    @Nullable    @Override    public IBinder onBind(Intent intent) {        Toast.makeText(getApplicationContext(), &amp;quot;binding&amp;quot;, Toast.LENGTH_SHORT).show();        return mMessenger.getBinder();    }    class IncomingHandler extends Handler {        @Override        public void handleMessage(Message msg) {            switch (msg.what) {                case MSG_SAY_HELLO:                    Toast.makeText(getApplicationContext(), &amp;quot;hello!&amp;quot;, Toast.LENGTH_SHORT).show();                    break;                default:                    super.handleMessage(msg);            }        }    }}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;activitymessager&#34;&gt;ActivityMessager&lt;/h2&gt;&lt;p&gt;客户端只需根据服务返回的 IBinder 创建一个 Messenger，然后利用 send() 发送一条消息。例如，以下就是一个绑定到服务并向服务传递 MSG_SAY_HELLO 消息的简单 Activity：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class ActivityMessenger extends Activity {    Messenger mService = null;    boolean mBound;    Button button;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        button = (Button) findViewById(R.id.button);        button.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                if (!mBound)                    return;                Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);                try {                    mService.send(msg);                } catch (RemoteException e) {                    e.printStackTrace();                }            }        });    }    @Override    protected void onStart() {        super.onStart();        Intent intent = new Intent(this, MessengerService.class);        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);    }    ServiceConnection mServiceConnection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {            mService = new Messenger(iBinder);            mBound = true;        }        @Override        public void onServiceDisconnected(ComponentName componentName) {            mBound = false;            mService = null;        }    };    @Override    protected void onStop() {        super.onStop();        if (mBound) {            unbindService(mServiceConnection);            mBound = false;        }    }}&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;注：只有 Activity、服务和内容提供程序可以绑定到服务—您无法从广播接收器绑定到服务。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;绑定到服务&#34;&gt;绑定到服务&lt;/h2&gt;&lt;p&gt;因此，要想从您的客户端绑定到服务，您必须：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;实现 ServiceConnection。&lt;/li&gt;&lt;li&gt;调用 bindService() 以传递 ServiceConnection 实现。&lt;/li&gt;&lt;li&gt;当系统调用您的 onServiceConnected() 回调方法时，您可以使用接口定义的方法开始调用服务。&lt;/li&gt;&lt;li&gt;要断开与服务的连接，请调用 unbindService()。&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&#34;附加说明&#34;&gt;附加说明&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;应该始终捕获 DeadObjectException 异常，它是在连接中断时引发的异常。这是远程方法引发的唯一异常&lt;/li&gt;&lt;li&gt;对象是跨进程计数的引用&lt;/li&gt;&lt;li&gt;如果您希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。这意味着您的 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当您提高该进程的权重时，系统终止该进程的可能性会增加&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;注：通常情况下，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，您应该使发生在这些转换期间的处理保持在最低水平。此外，如果您的应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一次绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务。 （Activity文档中介绍了这种有关 Activity 如何协调其生命周期的 Activity 转换。）&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;管理绑定服务的生命周期&#34;&gt;管理绑定服务的生命周期&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;当服务与所有客户端之间的绑定全部取消时，Android 系统便会销毁服务（除非还使用 onStartCommand() 启动了该服务）&lt;/li&gt;&lt;li&gt;不过，如果您选择实现 onStartCommand() 回调方法，则您必须显式停止服务，因为系统现在已将服务视为已启动。在此情况下，服务将一直运行到其通过 stopSelf() 自行停止，或其他组件调用 stopService() 为止，无论其是否绑定到任何客户端。&lt;/li&gt;&lt;li&gt;此外，如果您的服务已启动并接受绑定，则当系统调用您的 onUnbind() 方法时，如果您想在客户端下一次绑定到服务时接收 onRebind() 调用（而不是接收 onBind() 调用），则可选择返回 true。onRebind() 返回空值，但客户端仍在其 onServiceConnected() 回调中接收 IBinder。下文图 1 说明了这种生命周期的逻辑。&lt;/li&gt;&lt;/ul&gt;</description>
     </item>
   
     <item>
       <title>爛的故事</title>
       <link>https://wooi.github.io/posts/badstory1/</link>
       <pubDate>Tue, 11 Oct 2016 16:51:24 +0800</pubDate>
       
       <guid>https://wooi.github.io/posts/badstory1/</guid>
       <description>&lt;h1 id=&#34;爛的故事&#34;&gt;爛的故事&lt;/h1&gt;&lt;p&gt;一夜之間整個世界的女性全部消失了。有一個人，他擁有完美女性的樣貌和身材，但實際上他是一個徹頭徹尾的男人。面對外面其他男性的追求他很是煩惱，所以他決定就不出門了。&lt;/p&gt;&lt;p&gt;劇終&lt;/p&gt;</description>
     </item>
   
 </channel>
</rss>
